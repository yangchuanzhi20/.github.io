<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pytorch基础!🍧</title>
    <link href="/2024/01/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Pytorch/pytorch%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Pytorch/pytorch%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h2 id="1-Tensors张量"><a href="#1-Tensors张量" class="headerlink" title="1.Tensors张量"></a>1.Tensors张量</h2><p>张量是一种专门的数据结构，与数组和矩阵非常相似。在 PyTorch 中，我们使用张量对模型的输入和输出以及模型的参数进行编码。</p><p>张量类似于 NumPy 的 ndarrays，不同之处在于张量可以在 GPU 或其他硬件加速器上运行。事实上，张量和 NumPy 数组通常可以共享相同的底层内存，从而消除了复制数据的需要。</p><h3 id="1-1-初始化张量"><a href="#1-1-初始化张量" class="headerlink" title="1.1 初始化张量"></a>1.1 初始化张量</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p>张量可以通过多种方式进行初始化。</p><blockquote><p><strong>直接来自数据</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br>x_data = torch.tensor(data)<br></code></pre></td></tr></table></figure><blockquote><p><strong>从 NumPy 数组</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np_array = np.array(data)<br>x_np = torch.from_numpy(np_array)<br></code></pre></td></tr></table></figure><blockquote><p><strong>从另一个张量</strong></p></blockquote><p>新张量保留参数张量的属性（形状、数据类型），除非显式覆盖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x_ones = torch.ones_like(x_data) <span class="hljs-comment"># retains the properties of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;x_ones&#125;</span> \n&quot;</span>)<br><br>x_rand = torch.rand_like(x_data, dtype=torch.<span class="hljs-built_in">float</span>) <span class="hljs-comment"># overrides the datatype of x_data</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;x_rand&#125;</span> \n&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Ones Tensor:<br> tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])<br><br>Random Tensor:<br> tensor([[<span class="hljs-number">0.8823</span>, <span class="hljs-number">0.9150</span>],<br>        [<span class="hljs-number">0.3829</span>, <span class="hljs-number">0.9593</span>]])<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用随机值或常量值</strong></p></blockquote><p><code>shape</code> 是张量维度的元组。在下面的函数中，它决定了输出张量的维数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">shape = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,)<br>rand_tensor = torch.rand(shape)<br>ones_tensor = torch.ones(shape)<br>zeros_tensor = torch.zeros(shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Random Tensor: \n <span class="hljs-subst">&#123;rand_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ones Tensor: \n <span class="hljs-subst">&#123;ones_tensor&#125;</span> \n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Zeros Tensor: \n <span class="hljs-subst">&#123;zeros_tensor&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>tips：</strong>在给定形状（shape）时，逗号在 Python 中通常用于表示元组。在这种情况下，<code>shape = (2, 3,)</code> 中的逗号实际上是一个元组的标志，即使在没有逗号的情况下，它也是一个合法的元组。</p><p>这种写法是为了确保在定义元组时即使只有一个元素也使用逗号，以<strong>避免与普通的括号运算符产生歧义</strong>。例如，如果写成 <code>shape = (2, 3)</code>，它将被解释为一个包含两个整数的表达式，而不是一个包含一个元组的表达式。</p><p>在 Python 中，单个元素的元组需要在元素后面添加逗号，以明确表示这是一个元组。这是为了区分元组和括号内的表达式。所以，<code>(2, 3,)</code> 和 <code>(2, 3)</code> <strong>在这里是等价</strong>的，都表示一个包含两个整数的元组。</p><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">Random Tensor:<br> tensor([[<span class="hljs-number">0.3904</span>, <span class="hljs-number">0.6009</span>, <span class="hljs-number">0.2566</span>],<br>        [<span class="hljs-number">0.7936</span>, <span class="hljs-number">0.9408</span>, <span class="hljs-number">0.1332</span>]])<br><br>Ones Tensor:<br> tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br><br>Zeros Tensor:<br> tensor([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])<br></code></pre></td></tr></table></figure><h3 id="1-2-张量的属性"><a href="#1-2-张量的属性" class="headerlink" title="1.2 张量的属性"></a>1.2 张量的属性</h3><p>张量属性描述它们的形状、数据类型和存储它们的设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Shape of tensor: <span class="hljs-subst">&#123;tensor.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Datatype of tensor: <span class="hljs-subst">&#123;tensor.dtype&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device tensor is stored on: <span class="hljs-subst">&#123;tensor.device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Shape of tensor: torch.Size([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>Datatype of tensor: torch.float32<br>Device tensor <span class="hljs-keyword">is</span> stored on: cpu<br></code></pre></td></tr></table></figure><h3 id="1-3-张量操作"><a href="#1-3-张量操作" class="headerlink" title="1.3 张量操作"></a>1.3 张量操作</h3><p><a href="https://pytorch.org/docs/stable/torch.html">https://pytorch.org/docs/stable/torch.html</a></p><p>这里全面描述了 100 多种张量运算，包括算术、线性代数、矩阵操作（转置、索引、切片）、采样等。这些操作中的每一个都可以在 GPU 上运行（速度通常高于在 CPU 上）。</p><p>默认情况下，张量是在 CPU 上创建的。我们需要显式地将张量移动到 GPU using <code>.to</code> 方法（在检查 GPU 可用性之后）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># We move our tensor to the GPU if available</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    tensor = tensor.to(<span class="hljs-string">&quot;cuda&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>索引和切片</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.ones(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First row: <span class="hljs-subst">&#123;tensor[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;First column: <span class="hljs-subst">&#123;tensor[:, <span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Last column: <span class="hljs-subst">&#123;tensor[..., -<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br>tensor[:,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">First row: tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>First column: tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>Last column: tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br></code></pre></td></tr></table></figure><p><strong>tips：</strong>省略符号的作用是<strong>省略掉其余的维度</strong>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor = torch.rand((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(tensor)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tensor[:,:,:,<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tensor[..., <span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>...</code>等价于<code>:,:,:</code></p><p>连接张量 可用于 <code>torch.cat</code> 沿给定维度连接一系列张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = torch.cat([tensor, tensor, tensor], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br></code></pre></td></tr></table></figure><p><strong>tips：</strong>dim表示连接的维度。</p><blockquote><p><strong>算术运算</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This computes the matrix multiplication between two tensors. y1, y2, y3 will have the same value</span><br><span class="hljs-comment"># ``tensor.T`` returns the transpose of a tensor 转置矩阵</span><br>y1 = tensor @ tensor.T<br>y2 = tensor.matmul(tensor.T)<br><br>y3 = torch.rand_like(y1)<br>torch.matmul(tensor, tensor.T, out=y3)<br><br><br><span class="hljs-comment"># This computes the element-wise product. z1, z2, z3 will have the same value</span><br>z1 = tensor * tensor<br>z2 = tensor.mul(tensor)<br><br>z3 = torch.rand_like(tensor)<br>torch.mul(tensor, tensor, out=z3)<br></code></pre></td></tr></table></figure><ol><li><strong>矩阵乘法（Matrix Multiplication）</strong>：<ul><li><code>y1 = tensor @ tensor.T</code>：这是Python中使用<code>@</code>运算符进行<strong>矩阵乘法</strong>的简洁写法，它计算了<code>tensor</code>与其转置的矩阵相乘，并将结果存储在<code>y1</code>中。</li><li><code>y2 = tensor.matmul(tensor.T)</code>：这是<code>torch.Tensor</code>类的<code>matmul</code>方法的调用方式，实现了与<code>@</code>运算符相同的功能，将两个张量相乘。</li><li><code>y3 = torch.rand_like(y1)</code>和<code>torch.matmul(tensor, tensor.T, out=y3)</code>：这两行代码将矩阵乘法的结果存储在预先分配的张量<code>y3</code>中。</li></ul></li><li><strong>元素级乘法（Element-wise Multiplication）</strong>：<ul><li><code>z1 = tensor * tensor</code>：这是Python中进行元素级乘法的简洁写法，它将<code>tensor</code>中的每个元素与另一个<code>tensor</code>中<strong>对应位置的元素相乘</strong>，并将结果存储在<code>z1</code>中。</li><li><code>z2 = tensor.mul(tensor)</code>：这是<code>torch.Tensor</code>类的<code>mul</code>方法的调用方式，实现了与<code>*</code>运算符相同的功能，进行元素级乘法。</li><li><code>z3 = torch.rand_like(tensor)</code>和<code>torch.mul(tensor, tensor, out=z3)</code>：这两行代码将元素级乘法的结果存储在预先分配的张量<code>z3</code>中。</li></ul></li></ol><blockquote><p><strong>单元素张量</strong></p></blockquote><p>如果你有一个单元素张量，例如通过将张量的所有值聚合为一个值，你可以使用以下命令 <code>item()</code> 将其转换为 Python 数值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">agg = tensor.<span class="hljs-built_in">sum</span>()<br>agg_item = agg.item()<br><span class="hljs-built_in">print</span>(agg_item, <span class="hljs-built_in">type</span>(agg_item))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">12.0</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>tips：</strong>agg也是一个张量，为单元素张量。</p><blockquote><p><strong>就地操作</strong></p></blockquote><p>将结果存储到操作数中的操作称为就地操作。它们由 <code>_</code> 后缀表示。例如： <code>x.copy_(y)</code> 、、 <code>x.t_()</code> 将更改 <code>x</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;tensor&#125;</span> \n&quot;</span>)<br>tensor.add_(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(tensor)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>        [<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])<br><br>tensor([[<span class="hljs-number">6.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>, <span class="hljs-number">6.</span>],<br>        [<span class="hljs-number">6.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>, <span class="hljs-number">6.</span>],<br>        [<span class="hljs-number">6.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>, <span class="hljs-number">6.</span>],<br>        [<span class="hljs-number">6.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>, <span class="hljs-number">6.</span>]])<br></code></pre></td></tr></table></figure><p>常见的PyTorch就地操作：</p><ol><li>**add_、sub_、mul_、div_**：<ul><li><code>add_()</code>：就地执行张量的加法。</li><li><code>sub_()</code>：就地执行张量的减法。</li><li><code>mul_()</code>：就地执行张量的乘法。</li><li><code>div_()</code>：就地执行张量的除法。</li></ul></li><li><strong>其他数学函数</strong>：<ul><li><code>abs_()</code>：就地执行张量的绝对值操作。</li><li><code>neg_()</code>：就地执行张量的取负操作。</li><li><code>pow_()</code>：就地执行张量的指数操作。</li><li><code>clamp_()</code>：就地执行张量的截断操作。</li></ul></li><li><strong>归约操作</strong>：<ul><li><code>sum_()</code>：就地计算张量的元素之和。</li><li><code>mean_()</code>：就地计算张量的平均值。</li><li><code>max_()</code>：就地计算张量的最大值。</li><li><code>min_()</code>：就地计算张量的最小值。</li></ul></li><li><strong>其他操作</strong>：<ul><li><code>fill_()</code>：用指定的标量值填充张量。</li><li><code>zero_()</code>：将张量的所有元素设置为0。</li><li><code>fill_diagonal_()</code>：将张量的对角线元素填充为指定值。</li></ul></li></ol><p>这些就地操作都是在函数名后面添加下划线<code>_</code>来表示的，例如<code>add_()</code>、<code>mul_()</code>等。在使用时需要小心，因为它们会直接修改原始的张量，可能会导致不可预测的结果或难以调试的错误。</p><h3 id="1-4-使用-NumPy-桥接"><a href="#1-4-使用-NumPy-桥接" class="headerlink" title="1.4 使用 NumPy 桥接"></a>1.4 使用 NumPy 桥接</h3><p>CPU 上的张量和 NumPy 数组可以共享其底层内存位置，更改一个将更改另一个。</p><blockquote><h3 id="Tensor-到-NumPy-数组"><a href="#Tensor-到-NumPy-数组" class="headerlink" title="Tensor 到 NumPy 数组"></a>Tensor 到 NumPy 数组</h3></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.ones(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br>n = t.numpy()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t: tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>n: [<span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">1.</span>]<br></code></pre></td></tr></table></figure><p>张量的变化反映在 NumPy 数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t.add_(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t: tensor([<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>])<br>n: [<span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span>]<br></code></pre></td></tr></table></figure><blockquote><h3 id="NumPy-数组转-Tensor"><a href="#NumPy-数组转-Tensor" class="headerlink" title="NumPy 数组转 Tensor"></a>NumPy 数组转 Tensor</h3></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">n = np.ones(<span class="hljs-number">5</span>)<br>t = torch.from_numpy(n)<br></code></pre></td></tr></table></figure><p>NumPy 数组中的更改会反映在张量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.add(n, <span class="hljs-number">1</span>, out=n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;t: <span class="hljs-subst">&#123;t&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t: tensor([<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>], dtype=torch.float64)<br>n: [<span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span> <span class="hljs-number">2.</span>]<br></code></pre></td></tr></table></figure><h2 id="2-Datasets-DataLoaders-数据集和数据加载器"><a href="#2-Datasets-DataLoaders-数据集和数据加载器" class="headerlink" title="2.Datasets &amp; DataLoaders 数据集和数据加载器"></a>2.<strong>Datasets &amp; DataLoaders</strong> 数据集和数据加载器</h2><p>用于处理数据样本的代码可能会变得混乱且难以维护;理想情况下，我们希望我们的数据集代码与模型训练代码解耦，以获得更好的可读性和模块化。PyTorch 提供了两个数据原语： <code>torch.utils.data.DataLoader</code>和<code>torch.utils.data.Dataset</code> 允许你使用预加载的数据集以及你自己的数据。</p><p>Dataset 存储样本及其相应的标签，而 DataLoader 则在 Dataset 周围封装了一个可迭代器，以方便访问样本。</p>]]></content>
    
    
    <categories>
      
      <category>AI ʢᵕᴗᵕʡ</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ieir2024网站搭建!🐧</title>
    <link href="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="ieir2024网站搭建"><a href="#ieir2024网站搭建" class="headerlink" title="ieir2024网站搭建"></a>ieir2024网站搭建</h1><h2 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a>1.域名</h2><p>在<a href="https://www.gname.com/user#/admin_ym">我的域名 - GNAME管理中心</a>进行域名的注册和管理</p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/1.png"></p><p>解析域名：</p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/2.png"></p><p>前两条为SSL证书的DCV配置，后两条是正常的域名解析，解析到对应的服务器地址。</p><h2 id="2-SSL证书"><a href="#2-SSL证书" class="headerlink" title="2.SSL证书"></a>2.SSL证书</h2><h3 id="2-1-证书申请"><a href="#2-1-证书申请" class="headerlink" title="2.1 证书申请"></a>2.1 证书申请</h3><p>在<a href="https://freessl.cn/">FreeSSL首页 - FreeSSL.cn一个提供免费HTTPS证书申请的网站</a>申请免费的证书</p><ul><li>Step1，输入域名</li><li>Step2，DCV配置：返回DNS配置页面，添加两条主机记录（带www和不带www），立即检测。</li></ul><p>检测通过后会进入部署阶段，得到acme.sh部署命令。</p><h3 id="2-2-证书下载"><a href="#2-2-证书下载" class="headerlink" title="2.2 证书下载"></a>2.2 证书下载</h3><p>首先创建证书目录，root&#x2F;ssl-cert&#x2F;ieir2024.org</p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/3.png"></p><p>运行FreeSSL部署命令（FreeSSL网站给出）</p><p>最后下载证书到上面创建的目录</p><p>acme.sh –install-cert -d ieir2024.org –cert-file      &#x2F;root&#x2F;ssl_cert&#x2F;ieir2024.org&#x2F;cert.pem  –key-file       &#x2F;root&#x2F;ssl_cert&#x2F;ieir2024.org&#x2F;key.pem  –fullchain-file &#x2F;root&#x2F;ssl_cert&#x2F;ieir2024.org&#x2F;fullchain.pem –ca-file        &#x2F;root&#x2F;ssl_cert&#x2F;ieir2024.org&#x2F;ca.pem </p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/4.png"></p><h3 id="2-3-配置ssl-conf"><a href="#2-3-配置ssl-conf" class="headerlink" title="2.3 配置ssl.conf"></a>2.3 配置ssl.conf</h3><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/5.png"></p><p>将其中所有去年的网站名称改成今年的内容。</p><p>DocumentRoot “&#x2F;var&#x2F;www&#x2F;html&#x2F;ieir2024”（修改这个路径下的文件夹名称）</p><h3 id="2-4-重启httpd服务"><a href="#2-4-重启httpd服务" class="headerlink" title="2.4 重启httpd服务"></a>2.4 重启httpd服务</h3><p><code>systemctl restart httpd</code></p><p><code>service httpd force-reload</code></p><h2 id="3-修改网站"><a href="#3-修改网站" class="headerlink" title="3.修改网站"></a>3.修改网站</h2><p>使用Xftp进入<code>/var/www/html/ieir2024</code>路径下的目录。</p><p><strong>Key Dates:</strong></p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/6.png"></p><p><strong>News:</strong></p><p><img src="/2024/01/19/%E7%BD%91%E7%AB%99/%E7%BD%91%E7%AB%99%E5%AE%9E%E4%BE%8B/ieir2024/ieir2024%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/7.png"></p>]]></content>
    
    
    <categories>
      
      <category>网站 (✪㉨✪)</category>
      
      <category>网站实例</category>
      
      <category>ieir2024</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站</tag>
      
      <tag>实例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust基础知识！🐖</title>
    <link href="/2024/01/18/%E7%AE%97%E6%B3%95/rust/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/18/%E7%AE%97%E6%B3%95/rust/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="rust基础知识"><a href="#rust基础知识" class="headerlink" title="rust基础知识"></a>rust基础知识</h1><h2 id="1-Cargo"><a href="#1-Cargo" class="headerlink" title="1.Cargo"></a>1.Cargo</h2><p>Cargo 是 Rust 的<code>构建系统</code>和<code>包管理器</code>。Rust 开发者常用 Cargo 来管理 Rust 工程和获取工程所依赖的库。</p><p><img src="/2024/01/18/%E7%AE%97%E6%B3%95/rust/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png"></p><p>Cargo 除了创建工程以外还具备构建（build）工程、运行（run）工程等一系列功能，构建和运行分别对应以下命令：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo build <br>cargo run <br></code></pre></td></tr></table></figure><h2 id="2-输出到命令行"><a href="#2-输出到命令行" class="headerlink" title="2.输出到命令行"></a>2.输出到命令行</h2><p>Rust 输出文字的方式主要有两种：<code>println!()</code> 和 <code>print!()</code>。这两个”函数”都是向命令行输出字符串的方法，区别仅在于前者会在输出的最后附加输出一个<strong>换行符</strong>。当用这两个”函数”输出信息的时候，第一个参数是格式字符串，后面是一串可变参数，对应着格式字符串中的”占位符”，这一点与 C 语言中的 printf 函数很相似。但是，Rust 中格式字符串中的占位符不是 <strong>“% + 字母”</strong> 的形式，而是一对 <code>&#123;&#125;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">12</span>; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a is &#123;&#125;&quot;</span>, a); <br>&#125;<br></code></pre></td></tr></table></figure><p>如果我想把 a 输出两遍：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a is &#123;0&#125;, a again is &#123;0&#125;&quot;</span>, a); <br></code></pre></td></tr></table></figure><p>在 {}之间可以放一个数字，它将把之后的可变参数当作一个数组来访问，下标从 0 开始。</p><p>如果要输出 { 或 } 怎么办呢？格式字符串中通过  分别转义代表 { 和 }。但是其他常用转义字符与 C 语言里的转义字符一样，都是<strong>反斜杠开头</strong>的形式。</p><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><p>Rust 是<strong>强类型语言</strong>，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。</p><p>如果要声明变量，需要使用 <strong>let</strong> 关键字。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>在这句声明语句之后，以下三行代码都是被禁止的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">a = <span class="hljs-string">&quot;abc&quot;</span>;<br>a = <span class="hljs-number">4.56</span>; <br>a = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure><ul><li>第一行的错误在于当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。</li><li>第二行的错误在于自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换。</li><li>第三行的错误在于 a 不是个可变变量。</li></ul><p>前两种错误很容易理解，但第三个是什么意思？难道 a 不是个变量吗？</p><p>这就牵扯到了 Rust 语言为了高并发安全而做的设计：在语言层面<strong>尽量少的让变量的值可以改变</strong>。所以 a 的值不可变。但这**不意味着 a 不是”变量”**（英文中的 variable），官方文档称 a 这种变量为”不可变变量”。</p><p>如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。</p><p>当然，使变量变得”可变”（mutable）只需一个 <strong>mut</strong> 关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">123</span>;<br>a = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure><blockquote><h3 id="常量与不可变变量的区别"><a href="#常量与不可变变量的区别" class="headerlink" title="常量与不可变变量的区别"></a>常量与不可变变量的区别</h3></blockquote><p>既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？</p><p>变量和常量还是有区别的。在 Rust 中，以下程序是合法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">123</span>;   <span class="hljs-comment">// 可以编译，但可能有警告，因为该变量没有被使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure><p>但是如果 a 是常量就不合法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> a: <span class="hljs-type">i32</span> = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure><p>变量的值可以”重新绑定”，但在”重新绑定”以前不能私自被改变，这样可以确保在每一次”绑定”之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。</p><blockquote><h3 id="重影"><a href="#重影" class="headerlink" title="重影"></a>重影</h3></blockquote><p>重影的概念与其他面向对象语言里的”重写”（Override）或”重载”（Overload）是不一样的。重影就是刚才讲述的所谓”重新绑定”，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。</p><p>重影就是指变量的名称可以被重新使用的机制：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序的运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">The value of x is: <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>重影与可变变量的赋值不是一个概念，<strong>重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-string">&quot;123&quot;</span>;<br>s = s.<span class="hljs-title function_ invoke__">len</span>();<br></code></pre></td></tr></table></figure><p>这段程序会出错：不能给字符串变量赋整型值。</p><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h2><p>Rust 语言中的基础数据类型有以下几种。</p><h3 id="4-1-整数型（Integer）"><a href="#4-1-整数型（Integer）" class="headerlink" title="4.1 整数型（Integer）"></a>4.1 整数型（Integer）</h3><p>整数型简称整型，按照比特位长度和有无符号分为以下种类：</p><table><thead><tr><th>位长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p>isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。</p><p>整数的表述方法有以下几种：</p><table><thead><tr><th>进制</th><th>例</th></tr></thead><tbody><tr><td>十进制</td><td>98_222</td></tr><tr><td>十六进制</td><td>0xff</td></tr><tr><td>八进制</td><td>0o77</td></tr><tr><td>二进制</td><td>0b1111_0000</td></tr><tr><td>字节(只能表示 u8 型)</td><td>b’A’</td></tr></tbody></table><p>很显然，有的整数中间存在一个<strong>下划线</strong>，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少。</p><h3 id="4-2-浮点数型（Floating-Point）"><a href="#4-2-浮点数型（Floating-Point）" class="headerlink" title="4.2 浮点数型（Floating-Point）"></a>4.2 浮点数型（Floating-Point）</h3><p>Rust 与其它语言一样支持 32 位浮点数（f32）和 64 位浮点数（f64）。默认情况下，64.0 将表示 64 位浮点数，因为现代计算机处理器对两种浮点数计算的速度几乎相同，但 64 位浮点数精度更高。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// f64</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">3.0</span>; <span class="hljs-comment">// f32</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-数学运算"><a href="#4-3-数学运算" class="headerlink" title="4.3 数学运算"></a>4.3 数学运算</h3><p>用一段程序反映数学运算：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = <span class="hljs-number">5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">// 加 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">difference</span> = <span class="hljs-number">95.5</span> - <span class="hljs-number">4.3</span>; <span class="hljs-comment">// 减 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">product</span> = <span class="hljs-number">4</span> * <span class="hljs-number">30</span>; <span class="hljs-comment">// 乘 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">quotient</span> = <span class="hljs-number">56.7</span> / <span class="hljs-number">32.2</span>; <span class="hljs-comment">// 除 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">remainder</span> = <span class="hljs-number">43</span> % <span class="hljs-number">5</span>; <span class="hljs-comment">// 求余</span><br>&#125;<br></code></pre></td></tr></table></figure><p>许多运算符号之后加上 &#x3D; 号是自运算的意思，例如：</p><p><strong>sum +&#x3D; 1</strong> 等同于 <strong>sum &#x3D; sum + 1</strong>。</p><p><strong>注意：</strong>Rust 不支持 <strong>++</strong> 和 **–**，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。</p><h3 id="4-4-布尔型"><a href="#4-4-布尔型" class="headerlink" title="4.4 布尔型"></a>4.4 布尔型</h3><p>布尔型用 bool 表示，值只能为 true 或 false。</p><h3 id="4-5-字符型"><a href="#4-5-字符型" class="headerlink" title="4.5 字符型"></a>4.5 字符型</h3><p>字符型用 char 表示。</p><p>Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。</p><p>Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，”字符”这个概念并不存在于 Unicode 中，因此您对”字符”是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。</p><p><strong>注意：</strong>由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以<strong>在 Rust 中字符串和字符都必须使用 UTF-8 编码</strong>，否则编译器会报错。</p><h3 id="4-6-复合类型"><a href="#4-6-复合类型" class="headerlink" title="4.6 复合类型"></a>4.6 复合类型</h3><p><strong>元组</strong>是用一对 <strong>( )</strong> 包括的一组数据，可以包含不同种类的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// tup.0 等于 500</span><br><span class="hljs-comment">// tup.1 等于 6.4</span><br><span class="hljs-comment">// tup.2 等于 1</span><br><span class="hljs-keyword">let</span> (x, y, z) = tup;<br><span class="hljs-comment">// y 等于 6.4</span><br></code></pre></td></tr></table></figure><p><strong>数组</strong>用一对 <strong>[ ]</strong> 包括的同类型数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// a 是一个长度为 5 的整型数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = [<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>];<br><span class="hljs-comment">// b 是一个长度为 3 的字符串数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// c 是一个长度为 5 的 i32 数组</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br><span class="hljs-comment">// 等同于 let d = [3, 3, 3, 3, 3];</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 数组访问</span><br><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>; <span class="hljs-comment">// 错误：数组 a 不可变</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h2 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h2><p>Rust 中的注释方式与其它语言（C、Java）一样，支持两种注释方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这是第一种注释方式</span><br><br><span class="hljs-comment">/* 这是第二种注释方式 */</span> <br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 多行注释</span><br><span class="hljs-comment"> * 多行注释</span><br><span class="hljs-comment"> * 多行注释</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="5-1-用于说明文档的注释"><a href="#5-1-用于说明文档的注释" class="headerlink" title="5.1 用于说明文档的注释"></a>5.1 用于说明文档的注释</h3><p>在 Rust 中使用 <strong>&#x2F;&#x2F;</strong> 可以使其之后到第一个换行符的内容变成注释。</p><p>在这种规则下，三个正斜杠 <strong>&#x2F;&#x2F;&#x2F;</strong> 依然是合法的注释开始。所以 Rust 可以用 <strong>&#x2F;&#x2F;&#x2F;</strong> 作为说明文档注释的开头：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Adds one to the number given. </span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// # Examples </span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// ``` </span><br><span class="hljs-comment">/// let x = add(1, 2); </span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// ``` </span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; <br>    <span class="hljs-keyword">return</span> a + b; <br>&#125; <br>    <br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <br>&#125;<br></code></pre></td></tr></table></figure><p>程序中的函数 add 就会拥有一段优雅的注释，并可以显示：</p><p><img src="/2024/01/18/%E7%AE%97%E6%B3%95/rust/rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png"></p><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h2><p>函数在 Rust 语言中是普遍存在的。</p><p>通过之前的章节已经可以了解到 Rust 函数的基本形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;<br></code></pre></td></tr></table></figure><p>其中 Rust 函数名称的命名风格是<strong>小写字母以下划线分割</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    <span class="hljs-title function_ invoke__">another_function</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">another_function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, runoob!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">Hello, world!<br>Hello, runoob!<br></code></pre></td></tr></table></figure><p>注意，我们在源代码中的 main 函数之后定义了another_function。 Rust<strong>不在乎您在何处定义函数</strong>，只需在某个地方定义它们即可。</p><h3 id="6-1-函数参数"><a href="#6-1-函数参数" class="headerlink" title="6.1 函数参数"></a>6.1 函数参数</h3><p>Rust 中定义函数如果需要具备参数必须声明参数名称和类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">another_function</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">another_function</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">x 的值为 : <span class="hljs-number">5</span><br>y 的值为 : <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="6-2-函数体的语句和表达式"><a href="#6-2-函数体的语句和表达式" class="headerlink" title="6.2 函数体的语句和表达式"></a>6.2 函数体的语句和表达式</h3><p>Rust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成。到目前为止，我们仅见到了没有以表达式结尾的函数，但已经将表达式用作语句的一部分。</p><p>语句是执行某些操作且没有返回值的步骤。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>这个步骤没有返回值，所以以下语句不正确：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = (<span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>表达式有计算步骤且有返回值。以下是表达式（假设出现的标识符已经被定义）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">a = <span class="hljs-number">7</span><br>b + <span class="hljs-number">2</span><br>c * (a + b)<br></code></pre></td></tr></table></figure><p>Rust 中可以在一个用 <strong>{}</strong> 包括的块里编写一个较为复杂的表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br>        x + <span class="hljs-number">1</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">x 的值为 : <span class="hljs-number">5</span><br>y 的值为 : <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>很显然，这段程序中包含了一个表达式块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br>    x + <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而且在块中可以使用函数语句，最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做函数体表达式。</p><p>注意：<strong>x + 1</strong> 之后没有分号，否则它将变成一条语句！</p><p>这种表达式块是一个合法的函数体。而且在 Rust 中，函数定义可以嵌套：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">five</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">5</span><br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;five() 的值为: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">five</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-函数返回值"><a href="#6-3-函数返回值" class="headerlink" title="6.3 函数返回值"></a>6.3 函数返回值</h3><p>在上一个嵌套的例子中已经显示了 Rust 函数声明返回值类型的方式：在参数声明之后用 <strong>-&gt;</strong> 来声明函数返回值的类型（不是 <strong>:</strong> ）。</p><p>在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。这也是最接近大多数开发者经验的做法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是 Rust 不支持自动返回值类型判断！如果没有明确声明函数返回值的类型，函数将被认为是”纯过程”，不允许产生返回值，return 后面不能有返回值表达式。这样做的目的是为了让公开的函数能够形成可见的公报。</p><p><strong>注意：</strong>函数体表达式并不能等同于函数体，它不能使用 <strong>return</strong> <strong>关键字。</strong></p><h2 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7.条件语句"></a>7.条件语句</h2><p>在 Rust 语言中的条件语句是这种格式的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-number">3</span>; <br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span> &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;条件为 true&quot;</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;条件为 false&quot;</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>在上述程序中有条件 if 语句，这个语法在很多其它语言中很常见，但也有一些区别：首先，条件表达式 number &lt; 5 不需要用小括号包括（注意，不需要不是不允许）；但是 Rust 中的 if <strong>不存在单语句不用加 {} 的规则</strong>，<strong>不允许使用一个语句代替一个块</strong>。尽管如此，Rust 还是支持传统 else-if 语法的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">12</span>; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>; <br>    <span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">0</span> &#123; <br>        b = <span class="hljs-number">1</span>; <br>    &#125;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123; <br>        b = -<span class="hljs-number">1</span>; <br>    &#125;  <br>    <span class="hljs-keyword">else</span> &#123; <br>        b = <span class="hljs-number">0</span>; <br>    &#125; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b is &#123;&#125;&quot;</span>, b); <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">b 为 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>Rust 中的条件表达式必须是 bool 类型，例如下面的程序是错误的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-number">3</span>; <br>    <span class="hljs-keyword">if</span> number &#123;   <span class="hljs-comment">// 报错，expected `bool`, found integerrustc(E0308)</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>虽然 C&#x2F;C++ 语言中的条件表达式用整数表示，非 0 即真，但这个规则在很多注重代码安全性的语言中是被禁止的。</p><p>结合之前章学习的函数体表达式我们加以联想：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> &lt;condition&gt; &#123; block <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; block <span class="hljs-number">2</span> &#125; <br></code></pre></td></tr></table></figure><p>这种语法中的 <strong>{ block 1 }</strong> 和 <strong>{ block 2 }</strong> 可不可以是函数体表达式呢？</p><p>答案是肯定的！也就是说，在 Rust 中我们可以使用 if-else 结构实现类似于三元条件运算表达式 <strong>(A ? B : C)</strong> 的效果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">3</span>; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">0</span> &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-keyword">else</span> &#123; -<span class="hljs-number">1</span> &#125;; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number 为 &#123;&#125;&quot;</span>, number); <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">number 为 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：两个函数体表达式的<strong>类型必须一样</strong>！且必须有一个 else 及其后的表达式块。</p><h2 id="8-循环"><a href="#8-循环" class="headerlink" title="8.循环"></a>8.循环</h2><h3 id="8-1-while-循环"><a href="#8-1-while-循环" class="headerlink" title="8.1 while 循环"></a>8.1 while 循环</h3><p>while 循环是最典型的条件语句循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">number</span> = <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span> number != <span class="hljs-number">4</span> &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, number); <br>        number += <span class="hljs-number">1</span>; <br>    &#125; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;EXIT&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>EXIT<br></code></pre></td></tr></table></figure><p>Rust 语言到此教程编撰之日还没有 do-while 的用法，但是 do 被规定为保留字，也许以后的版本中会用到。</p><p>在 C 语言中 for 循环使用三元语句控制循环，但是 Rust 中没有这种用法，需要用 while 循环来代替：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i; <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span> &#123; <br>    <span class="hljs-comment">// 循环体 </span><br>    i += <span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-for-循环"><a href="#8-2-for-循环" class="headerlink" title="8.2 for 循环"></a>8.2 for 循环</h3><p>for 循环是最常用的循环结构，常用来遍历一个线性数据结构（比如数组）。for 循环遍历数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]; <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;值为 : &#123;&#125;&quot;</span>, i); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">值为 : <span class="hljs-number">10</span><br>值为 : <span class="hljs-number">20</span><br>值为 : <span class="hljs-number">30</span><br>值为 : <span class="hljs-number">40</span><br>值为 : <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>这个程序中的 for 循环完成了对数组 a 的遍历。a.iter() 代表 a 的迭代器（iterator），在学习有关于对象的章节以前不做赘述。</p><p>当然，for 循环其实是可以通过下标来访问数组的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]; <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a[&#123;&#125;] = &#123;&#125;&quot;</span>, i, a[i]); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">a[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">30</span><br>a[<span class="hljs-number">3</span>] = <span class="hljs-number">40</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h3 id="8-3-loop-循环"><a href="#8-3-loop-循环" class="headerlink" title="8.3 loop 循环"></a>8.3 loop 循环</h3><p>身经百战的开发者一定遇到过几次这样的情况：某个循环无法在开头和结尾判断是否继续进行循环，必须在循环体中间某处控制循环的进行。如果遇到这种情况，我们经常会在一个 while (true) 循环体里实现中途退出循环的操作。</p><p>Rust 语言有原生的无限循环结构 —— loop：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = [<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">loop</span> &#123; <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = s[i]; <br>        <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;O&#x27;</span> &#123; <br>            <span class="hljs-keyword">break</span>; <br>        &#125; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\&#x27;&#123;&#125;\&#x27;&quot;</span>, ch);<br>        i += <span class="hljs-number">1</span>; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-string">&#x27;R&#x27;</span> <br><span class="hljs-string">&#x27;U&#x27;</span> <br><span class="hljs-string">&#x27;N&#x27;</span> <br></code></pre></td></tr></table></figure><p>loop 循环可以通过 break 关键字类似于 return 一样使整个循环退出并给予外部一个返回值。这是一个十分巧妙的设计，因为 loop 这样的循环常被用来当作查找工具使用，如果找到了某个东西当然要将这个结果交出去：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = [<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>]; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">location</span> = <span class="hljs-keyword">loop</span> &#123; <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = s[i];<br>        <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;O&#x27;</span> &#123; <br>            <span class="hljs-keyword">break</span> i; <br>        &#125; <br>        i += <span class="hljs-number">1</span>; <br>    &#125;; <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot; \&#x27;O\&#x27; 的索引为 &#123;&#125;&quot;</span>, location); <br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-string">&#x27;O&#x27;</span> 的索引为 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="9-所有权"><a href="#9-所有权" class="headerlink" title="9.所有权"></a>9.所有权</h2><p>计算机程序必须在运行时管理它们所使用的内存资源。大多数的编程语言都有管理内存的功能：C&#x2F;C++ 这样的语言主要通过手动方式管理内存，开发者需要手动的申请和释放内存资源。但为了提高开发效率，只要不影响程序功能的实现，许多开发者没有及时释放内存的习惯。所以手动管理内存的方式常常造成资源浪费。</p><p>所有权对大多数开发者而言是一个新颖的概念，它是 Rust 语言为高效使用内存而设计的语法机制。所有权概念是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。</p><h3 id="9-1-所有权规则"><a href="#9-1-所有权规则" class="headerlink" title="9.1 所有权规则"></a>9.1 所有权规则</h3><p>所有权有以下三条规则：</p><ul><li>Rust 中的每个值都有一个变量，称为其所有者。</li><li>一次只能有一个所有者。</li><li>当所有者不在程序运行范围时，该值将被删除。</li></ul><p>这三条规则是所有权概念的基础。</p><h3 id="9-2-变量范围"><a href="#9-2-变量范围" class="headerlink" title="9.2 变量范围"></a>9.2 变量范围</h3><p>我们用下面这段程序描述变量范围的概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-comment">// 在声明以前，变量 s 无效</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;runoob&quot;</span>;<br>    <span class="hljs-comment">// 这里是变量 s 的可用范围</span><br>&#125;<br><span class="hljs-comment">// 变量范围已经结束，变量 s 无效</span><br></code></pre></td></tr></table></figure><p>变量范围是变量的一个属性，其代表变量的可行域，默认从声明变量开始有效直到变量所在域结束。</p><p>我们把字符串样例程序用 C 语言等价编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">char</span> *s = strdup(<span class="hljs-string">&quot;runoob&quot;</span>);<br>    <span class="hljs-built_in">free</span>(s); <span class="hljs-comment">// 释放 s 资源</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ust 之所以没有明示释放的步骤是因为在变量范围结束的时候，Rust 编译器自动添加了调用释放资源函数的步骤。</p><p>这种机制看似很简单了：它不过是帮助程序员在适当的地方添加了一个释放资源的函数调用而已。但这种简单的机制可以有效地解决一个史上最令程序员头疼的编程问题。</p><h3 id="9-3-变量与数据交互的方式"><a href="#9-3-变量与数据交互的方式" class="headerlink" title="9.3 变量与数据交互的方式"></a>9.3 变量与数据交互的方式</h3><p>变量与数据交互方式主要有移动（Move）和克隆（Clone）两种：</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python杂项！🍩</title>
    <link href="/2023/12/18/%E7%AE%97%E6%B3%95/python/python%E6%9D%82%E9%A1%B9/"/>
    <url>/2023/12/18/%E7%AE%97%E6%B3%95/python/python%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="python杂项"><a href="#python杂项" class="headerlink" title="python杂项"></a>python杂项</h1><h2 id="1-all的使用"><a href="#1-all的使用" class="headerlink" title="1.all的使用"></a>1.all的使用</h2><p>在Python中，<code>all()</code> 是一个内置函数，用于检查可迭代对象中的所有元素是否都为真（即非零、非空、非None等）。它的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">all</span>(iterable)<br></code></pre></td></tr></table></figure><p>其中，<code>iterable</code> 是一个可迭代对象，例如列表、元组、集合等。</p><p><code>all()</code> 函数返回一个布尔值：</p><ul><li>如果可迭代对象中的所有元素都为真，返回 <code>True</code>。</li><li>如果可迭代对象中有至少一个元素为假，返回 <code>False</code>。</li></ul><p>下面是一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例 1</span><br>my_list = [<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>]<br>result = <span class="hljs-built_in">all</span>(my_list)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 True，因为所有元素都为真</span><br><br><span class="hljs-comment"># 示例 2</span><br>my_list = [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]<br>result = <span class="hljs-built_in">all</span>(my_list)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 False，因为有一个元素为假</span><br><br><span class="hljs-comment"># 示例 3</span><br>my_dict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-literal">True</span>&#125;<br>result = <span class="hljs-built_in">all</span>(my_dict.values())<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 True，因为所有值都为真</span><br><br><span class="hljs-comment"># 示例 4</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>)<br>result = <span class="hljs-built_in">all</span>(my_tuple)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 False，因为有一个元素为假（0被视为假）</span><br><br><span class="hljs-comment"># 示例 5</span><br>my_set = &#123;<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>&#125;<br>result = <span class="hljs-built_in">all</span>(my_set)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 True，因为所有元素都为真</span><br></code></pre></td></tr></table></figure><p><code>all()</code> 对于检查某个条件是否对可迭代对象中的所有元素都成立很有用，例如在你的原始代码中，它用于检查所有 <code>run_predecessor</code> 对象的 <code>executed</code> 属性是否都为真。</p><h2 id="2-assert"><a href="#2-assert" class="headerlink" title="2.assert"></a>2.assert</h2><p>在Python中，<code>assert</code> 是一个关键字，用于在代码中加入断言。断言是一种声明，用于在代码中确保某个条件为真。如果断言的条件为假，那么程序将引发 <code>AssertionError</code> 异常。</p><p><code>assert</code> 的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> expression[, message]<br></code></pre></td></tr></table></figure><p>其中，<code>expression</code> 是一个要测试的条件，如果为假，则引发异常。可选的 <code>message</code> 参数是一个字符串，用于在引发异常时显示一条自定义的错误消息。</p><p>下面是一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例 1</span><br>x = <span class="hljs-number">5</span><br><span class="hljs-keyword">assert</span> x == <span class="hljs-number">5</span>  <span class="hljs-comment"># 什么都不会发生，因为 x 等于 5</span><br><br><span class="hljs-comment"># 示例 2</span><br>y = <span class="hljs-number">10</span><br><span class="hljs-keyword">assert</span> y &gt; <span class="hljs-number">15</span>, <span class="hljs-string">&quot;y 应该大于 15&quot;</span>  <span class="hljs-comment"># 引发 AssertionError，因为 y 不大于 15</span><br><br><span class="hljs-comment"># 示例 3</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;这个表达式总是为假&quot;</span>  <span class="hljs-comment"># 引发 AssertionError，附带自定义错误消息</span><br><br><span class="hljs-comment"># 示例 4</span><br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) &gt; <span class="hljs-number">5</span>, <span class="hljs-string">&quot;列表长度应该大于 5&quot;</span>  <span class="hljs-comment"># 引发 AssertionError，因为列表长度不大于 5</span><br></code></pre></td></tr></table></figure><p>在开发中，<code>assert</code> 通常用于在开发和测试阶段对代码进行调试，确保某些条件得到满足。然而，它不应该用于处理正常的错误检查和错误处理。在生产环境中，可以通过关闭解释器的断言来忽略所有断言语句，以提高性能。</p><p>请注意，当使用 <code>-O</code>（大写字母O）选项运行Python脚本时，断言将被禁用。这是为了在生产环境中避免执行断言检查。</p><h2 id="3-包导入"><a href="#3-包导入" class="headerlink" title="3.包导入"></a>3.包导入</h2><p>这是 Python 中的相对导入语法。具体而言，<code>from .graph_of_states import GraphOfStates</code> 语句表明你正在从当前模块的相对路径中导入 <code>GraphOfStates</code> 类。</p><p>让我解释一下：</p><ul><li><code>.</code> 表示当前目录或模块。在这种上下文中，它指的是当前包（package）或模块（module）的路径。</li><li><code>graph_of_states</code> 是模块或包的名称。</li><li><code>GraphOfStates</code> 是从 <code>graph_of_states</code> 模块中导入的类或变量的名称。</li></ul><p>这种相对导入的语法在包内部的模块之间进行导入时很常见。例如，如果你有一个包（目录）叫做 <code>my_package</code>，里面有一个模块（文件）叫做 <code>main_module.py</code>，而在 <code>my_package</code> 中有一个子模块（文件）叫做 <code>graph_of_states.py</code>，包含了 <code>GraphOfStates</code> 类，那么在 <code>main_module.py</code> 中，你可以使用相对导入来引入 <code>GraphOfStates</code> 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .graph_of_states <span class="hljs-keyword">import</span> GraphOfStates<br></code></pre></td></tr></table></figure><p>这样的语句使得代码更具可维护性，因为你不需要指定完整的模块路径。</p><h2 id="4-argparse"><a href="#4-argparse" class="headerlink" title="4.argparse"></a>4.argparse</h2><p><code>argparse</code> 是 Python 标准库中用于处理命令行参数的模块。它提供了一种简单而灵活的方式来解析命令行参数，并生成帮助信息。以下是 <code>argparse</code> 模块的基本用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建 ArgumentParser 对象</span><br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;描述你的脚本的用途&#x27;</span>)<br><br>    <span class="hljs-comment"># 添加位置参数（Positional Arguments）</span><br>    parser.add_argument(<span class="hljs-string">&#x27;input_file&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;输入文件的路径&#x27;</span>)<br><br>    <span class="hljs-comment"># 添加可选参数（Optional Arguments）</span><br>    parser.add_argument(<span class="hljs-string">&#x27;-o&#x27;</span>, <span class="hljs-string">&#x27;--output&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;输出文件的路径&#x27;</span>)<br><br>    <span class="hljs-comment"># 添加一个布尔型标志参数</span><br>    parser.add_argument(<span class="hljs-string">&#x27;-v&#x27;</span>, <span class="hljs-string">&#x27;--verbose&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;显示详细信息&#x27;</span>)<br><br>    <span class="hljs-comment"># 解析命令行参数</span><br>    args = parser.parse_args()<br><br>    <span class="hljs-comment"># 使用解析后的参数</span><br>    input_file = args.input_file<br>    output_file = args.output<br>    verbose = args.verbose<br><br>    <span class="hljs-comment"># 在这里执行你的程序逻辑</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;输入文件: <span class="hljs-subst">&#123;input_file&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;输出文件: <span class="hljs-subst">&#123;output_file&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;详细信息: <span class="hljs-subst">&#123;verbose&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>argparse.ArgumentParser</code> 用于创建一个解析器对象。然后，使用 <code>add_argument</code> 方法添加位置参数和可选参数。最后，通过调用 <code>parse_args</code> 方法解析命令行参数，并返回一个包含解析结果的对象。</p><p>运行脚本时，可以使用以下命令行参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python script.py <span class="hljs-built_in">input</span>.txt -o output.txt -v<br></code></pre></td></tr></table></figure><p>解析后，<code>args.input_file</code> 将包含输入文件的路径，<code>args.output</code> 将包含输出文件的路径，而 <code>args.verbose</code> 将为 <code>True</code>，因为 <code>-v</code> 标志已经被指定。</p><p>使用 <code>python script.py -h</code> 或 <code>python script.py --help</code> 可以显示帮助信息，其中包含关于位置参数和可选参数的说明。</p><h2 id="5-yaml"><a href="#5-yaml" class="headerlink" title="5.yaml"></a>5.yaml</h2><p>YAML（YAML Ain’t Markup Language或YAML是一种人类可读的数据序列化格式。它经常用于配置文件和数据交换格式，因为它与JSON类似，但具有更容易阅读的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br><span class="hljs-comment"># 读取YAML文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.yaml&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    yaml_data = yaml.safe_load(file)<br><br><span class="hljs-comment"># yaml_data现在是包含YAML数据的Python对象（通常是字典或列表）</span><br><span class="hljs-built_in">print</span>(yaml_data)<br></code></pre></td></tr></table></figure><p>使用PyYAML生成YAML数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br><span class="hljs-comment"># 定义一个包含数据的Python对象</span><br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;New York&#x27;</span>&#125;<br><br><span class="hljs-comment"># 使用yaml.dump将Python对象转换为YAML字符串</span><br>yaml_string = yaml.dump(data)<br><br><span class="hljs-comment"># 打印生成的YAML字符串</span><br><span class="hljs-built_in">print</span>(yaml_string)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>PyYAML中的<code>yaml.safe_load</code>用于安全地加载YAML数据，以避免潜在的安全风险。在加载不受信任的YAML数据时，应使用<code>safe_load</code>而不是<code>load</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># example.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">John</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">30</span><br><span class="hljs-attr">city:</span> <span class="hljs-string">New</span> <span class="hljs-string">York</span><br></code></pre></td></tr></table></figure><p>为了增加安全性，自 PyYAML 版本 5.1.0 开始，它引入了默认的安全限制，不再允许加载任意类的对象。因此，在使用 <code>yaml.load</code> 时，为了避免潜在的安全风险，建议传递 <code>Loader=yaml.FullLoader</code> 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br><span class="hljs-comment"># 使用 FullLoader 加载 YAML 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.yaml&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    yaml_data = yaml.load(file, Loader=yaml.FullLoader)<br><br><span class="hljs-comment"># yaml_data 现在是包含 YAML 数据的 Python 对象（通常是字典或列表）</span><br><span class="hljs-built_in">print</span>(yaml_data)<br></code></pre></td></tr></table></figure><p>这样的做法防止了潜在的代码注入攻击，因为 <code>yaml.FullLoader</code> 不会加载任意类的对象，只会加载基本的 Python 数据类型。在加载不受信任的 YAML 数据时，使用 <code>yaml.FullLoader</code> 是一个很好的做法。</p><p>在较早的版本中，<code>yaml.load</code> 是不安全的，因为它可以加载任意 Python 对象，包括不安全的对象。因此，为了防止安全漏洞，建议在使用 PyYAML 时明确指定 <code>Loader</code> 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br><span class="hljs-comment"># 使用 FullLoader 加载 YAML 文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.yaml&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    yaml_data = yaml.load(file, Loader=yaml.FullLoader)<br><br><span class="hljs-comment"># yaml_data 现在是包含 YAML 数据的 Python 对象（通常是字典或列表）</span><br><span class="hljs-built_in">print</span>(yaml_data)<br></code></pre></td></tr></table></figure><p>这样的做法防止了潜在的代码注入攻击，因为 <code>yaml.FullLoader</code> 不会加载任意类的对象，只会加载基本的 Python 数据类型。在加载不受信任的 YAML 数据时，使用 <code>yaml.FullLoader</code> 是一个很好的做法。</p><p>在较早的版本中，<code>yaml.load</code> 是不安全的，因为它可以加载任意 Python 对象，包括不安全的对象。因此，为了防止安全漏洞，建议在使用 PyYAML 时明确指定 <code>Loader</code> 参数。</p><h2 id="6-getattr"><a href="#6-getattr" class="headerlink" title="6.getattr"></a>6.getattr</h2><p><code>getattr</code> 是一个内建函数，用于获取对象的属性值。其基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">object</span>, name[, default])<br></code></pre></td></tr></table></figure><ul><li><code>object</code>: 要获取属性的对象。</li><li><code>name</code>: 属性的名称。</li><li><code>default</code> (可选): 如果属性不存在，返回的默认值。</li></ul><p>下面是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><span class="hljs-comment"># 创建一个 Person 对象</span><br>person = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>)<br><br><span class="hljs-comment"># 使用 getattr 获取属性值</span><br>name_value = <span class="hljs-built_in">getattr</span>(person, <span class="hljs-string">&#x27;name&#x27;</span>)<br>age_value = <span class="hljs-built_in">getattr</span>(person, <span class="hljs-string">&#x27;age&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Name: <span class="hljs-subst">&#123;name_value&#125;</span>, Age: <span class="hljs-subst">&#123;age_value&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>getattr</code> 被用来获取 <code>person</code> 对象的 <code>name</code> 和 <code>age</code> 属性的值。当然，这只是一个简单的演示。在实际应用中，<code>getattr</code> 可能会更有用，例如，当你需要根据动态的属性名称来访问对象的属性时。</p><p>如果属性不存在，你可以提供一个默认值作为 <code>default</code> 参数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">gender_value = <span class="hljs-built_in">getattr</span>(person, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Gender: <span class="hljs-subst">&#123;gender_value&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这里，如果 <code>gender</code> 属性不存在，就会返回默认值 <code>&#39;Unknown&#39;</code>。</p><p>总的来说，<code>getattr</code> 是一个灵活的工具，特别适用于需要动态访问对象属性的情况。</p><p><code>getattr</code> 函数可用于获取对象的属性，并且可以结合括号 <code>()</code> 调用属性值，前提是该属性是可调用的（即是一个方法）。这样的使用情况通常在需要动态调用对象的方法时会比较有用。</p><p>下面是一个示例，假设 <code>state</code> 是一个对象，而 <code>st_k</code> 是该对象的一个方法的名称，你可以使用 <code>getattr(state, st_k)</code> 获取该方法，并通过 <code>()</code> 调用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is method 1&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is method 2&quot;</span><br><br><span class="hljs-comment"># 创建一个 State 对象</span><br>state = State()<br><br><span class="hljs-comment"># st_k 是一个方法的名称，例如 &#x27;method1&#x27; 或 &#x27;method2&#x27;</span><br>st_k = <span class="hljs-string">&#x27;method1&#x27;</span><br><br><span class="hljs-comment"># 使用 getattr 获取对象的方法，并调用它</span><br>result = <span class="hljs-built_in">getattr</span>(state, st_k)()<br><br><span class="hljs-comment"># 打印方法的返回值</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>st_k</code> 是一个方法的名称，<code>getattr(state, st_k)</code> 获取对象 <code>state</code> 中名为 <code>st_k</code> 的方法，然后通过 <code>()</code> 调用它。这种做法可以使代码更加灵活，允许在运行时选择要调用的方法。</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>珍珠耳环少女！🐅</title>
    <link href="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/"/>
    <url>/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="珍珠耳环少女"><a href="#珍珠耳环少女" class="headerlink" title="珍珠耳环少女"></a>珍珠耳环少女</h1><h2 id="1-参考图"><a href="#1-参考图" class="headerlink" title="1.参考图"></a>1.参考图</h2><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/1.png"></p><p>如上图所示：<code>shift + A</code>新建菜单下选择需要加载的参考图。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/2.png"></p><p>点击右侧窗口的图像属性。</p><p><strong>tips：</strong>点击什么类型的物体就会出现相应的属性。</p><p>举例：点击摄像机后的图案如下所示</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/3.png"></p><p>勾选不透明度，调整透明度方便后续建模。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/4.png"></p><p>点击选择键，使参考图在视窗内无法被选择。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/5.png"></p><p>调整深度，可以将参考图看的更清楚。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/7.png"></p><h2 id="2-建模"><a href="#2-建模" class="headerlink" title="2.建模"></a>2.建模</h2><p>新建一个经纬球和三个环体</p><p>在如下所示的窗口中修改新建物体的参数</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/6.png"></p><p><strong>tips1：</strong><code>/键</code>可以独显某一物体。</p><p>其余部分同上。</p><p><strong>tips2：</strong>定位过程中可以切换正视图和侧视图（1&#x2F;3键）调整物体位置，<code>正视图确定x和z方向</code>，<code>侧视图确定y方向</code>。</p><p>同时对于旋转物体，可以先确定中心点，然后按x，y，z三个旋转轴方向对物体进行旋转定位。<strong>物体最多旋转三次即可达到指定的旋转位置。</strong></p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/8.png"></p><p>模型最终效果如上所示。</p><h2 id="3-摄像机"><a href="#3-摄像机" class="headerlink" title="3.摄像机"></a>3.摄像机</h2><p>小键盘<code>0</code>切换摄像机模式。</p><p>快捷键：<code>ctrl + alt + 0</code>让摄像机视角快速定位到视图位置。</p><p>或者按快捷键<code>N</code>调出视图选项栏，选择锁定摄像机，这样就可以直接调节物体的角度。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/9.png"></p><p>点击输出设置，修改分辨率，如图所示</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/10.png"></p><p>修改后的摄像机为一个正方形。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/11.png"></p><p>修改渲染输出的位置，如下图所示</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/12.png"></p><p>点击进入摄像机的属性，调整外边框的数值，可以屏蔽摄像机视角外的内容，方便观察。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/13.png"></p><h2 id="4-渲染器"><a href="#4-渲染器" class="headerlink" title="4.渲染器"></a>4.渲染器</h2><table><thead><tr><th align="center">Render Engines</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td align="center">EEVEE</td><td>快</td><td>没有光线追踪</td></tr><tr><td align="center">CYCLES</td><td>逼真，模拟物理世界 细节的光线阴影</td><td>慢，更耗硬件</td></tr></tbody></table><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/14.png"></p><p>如上图所示修改渲染引擎。</p><p>快捷键<code>F12</code>或者按如下图所示渲染模型。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/15.png"></p><p><strong>tips：</strong>将鼠标放在视图上方的工具栏，向下滑动鼠标中键，可以将隐藏的菜单选项调出来。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/16.png"></p><p>如上图所示是四种视图的预览方式。</p><blockquote><p>线框预览</p></blockquote><p>可以显示内部和背面的走线，建模常用。</p><blockquote><p>实体预览</p></blockquote><p>不显示颜色和材质，建模时候使用，不占资源。</p><blockquote><p>材质预览</p></blockquote><p>预览材质的颜色和简单的纹理，不计算光纤追踪细节，比渲染预览快。</p><blockquote><p>渲染预览</p></blockquote><p>最终渲染结果预览，占资源</p><p><strong>tips：</strong>可以修改渲染使用的gpu设备。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/22.png"></p><h2 id="5-灯光"><a href="#5-灯光" class="headerlink" title="5.灯光"></a>5.灯光</h2><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/17.png"></p><p>点击灯光属性，调节半径，半径越大灯光越柔和。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/18.png"></p><p>改变世界属性中的强度&#x2F;力度参数，可以更准确的布光。</p><blockquote><p>新建灯光</p></blockquote><p><code>shift + A</code>选择灯光类型。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/20.png"></p><p>在灯光属性中调整参数修改布光。</p><p><strong>tips：</strong>可以在物体属性中勾选自动光滑，设置光滑角度，来保持某些物体的角度。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/21.png"></p><h2 id="6-材质"><a href="#6-材质" class="headerlink" title="6.材质"></a>6.材质</h2><p>如下图所示新建材质</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/23.png"></p><p>修改下面的基础参数进行材质的修改。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/24.png"></p><p><strong>tips：</strong>可在右上角新建集合，管理文件资源。</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/25.png"></p><blockquote><p>关联材质</p></blockquote><p>快捷键：<code>ctrl + L</code></p><p>关联材质的目的是将未上材质的物体与已经上材质的物体进行关联，使该物体具有和已上材质的物体同样的材质。</p><p>最终效果如下图所示：</p><p><img src="/2023/12/09/%E5%BB%BA%E6%A8%A1/blender/%E8%AE%BE%E8%AE%A1/blender%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E5%B0%91%E5%A5%B3/26.png"></p>]]></content>
    
    
    <categories>
      
      <category>建模 ʕథ౪థʔ</category>
      
      <category>Blender</category>
      
      <category>Blender建模案例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>界面认识！🥕</title>
    <link href="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/"/>
    <url>/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="界面认识"><a href="#界面认识" class="headerlink" title="界面认识"></a>界面认识</h1><h2 id="1-界面"><a href="#1-界面" class="headerlink" title="1.界面"></a>1.界面</h2><blockquote><p>窗口可替换</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/1.png"></p><p>如上图所示，每一个窗口都可以替换成不同的类型。</p><blockquote><p>窗口可拆分</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/2.png"></p><p>如上图所示，将鼠标放置在任一窗口的四角，往自己方向拖动可以新增一个窗口，往已存在的窗口拖动可以合并。</p><blockquote><p>窗口可恢复</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/3.png"></p><p>如上图所示，如果想要恢复到最初的窗口，可以按图示方法新建布局。</p><blockquote><p>最大化当前面板</p></blockquote><p>快捷键：<code>ctrl + space</code></p><p>再按一次返回。</p><h2 id="2-游标"><a href="#2-游标" class="headerlink" title="2.游标"></a>2.游标</h2><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/4.png"></p><p>点击上图的游标工具即可移动游标。或者在选择工具下<code>shift + 右键</code>进行移动。</p><blockquote><p>新建物体的位置</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/5.png"></p><p>如图所示，新建物体的位置会出现在游标所在的位置。</p><blockquote><p>模型定位</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/6.png"></p><p>如图所示，通过<code>shift + S</code>可以将模型的位置和游标进行联系。</p><p>游标回到原点快捷键：<code>shift + C</code></p><blockquote><p>物体旋转轴心点</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/7.png"></p><p>如图所示，改变物体变换轴心点为游标，物体的旋转则以游标为轴心</p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/8.png"></p><h2 id="3-原点"><a href="#3-原点" class="headerlink" title="3.原点"></a>3.原点</h2><p>物体的变换皆以原点为中心。</p><p>举例：如果不改变原点位置，则会进行下列变换</p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/9.png"></p><p>物体以原点为中心进行缩放。</p><blockquote><p>变换原点</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/10.png"></p><p>如图所示，使变换仅改变原点的位置。</p><p>在正视图的视角下，改变原点的位置，缩放将以该点为中心。</p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/11.png"></p><h2 id="4-偏好设置"><a href="#4-偏好设置" class="headerlink" title="4.偏好设置"></a>4.偏好设置</h2><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/12.png"></p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/13.png"></p><h2 id="5-变换轴心点"><a href="#5-变换轴心点" class="headerlink" title="5.变换轴心点"></a>5.变换轴心点</h2><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/14.png"></p><blockquote><p>边界框中心</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/15.png"></p><blockquote><p>各自的原点</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/16.png"></p><blockquote><p>质心点</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/17.png"></p><blockquote><p>活动元素</p></blockquote><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/18.png"></p><p>以最后一个选中的对象为中心，即中点为黄色的点。</p><h2 id="6-坐标"><a href="#6-坐标" class="headerlink" title="6.坐标"></a>6.坐标</h2><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/19.png"></p><blockquote><p>全局坐标</p></blockquote><p>世界坐标，即东南西北。</p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/20.png"></p><p>如图所示，全局坐标下，坐标轴不会随着物体的旋转而改变。</p><blockquote><p>局部坐标</p></blockquote><p>自身坐标，即上下左右。</p><p><img src="/2023/12/08/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/Blender%E7%95%8C%E9%9D%A2%E8%AE%A4%E8%AF%86/21.png"></p><p>如图所示，局部坐标下，坐标轴随着物体方向的改变而改变。</p><blockquote><p>切换全局 &#x2F; 局部</p></blockquote><p>先按快捷键并选择固定轴，再按一次选择轴即可切换。</p><p>举例：<code>G + Z (局部) + Z (全局)</code></p>]]></content>
    
    
    <categories>
      
      <category>建模 ʕథ౪థʔ</category>
      
      <category>Blender</category>
      
      <category>Blender建模技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器和itertools库的使用！🍩</title>
    <link href="/2023/12/08/%E7%AE%97%E6%B3%95/python/python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Citertools%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/08/%E7%AE%97%E6%B3%95/python/python%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8Citertools%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器和itertools库的使用"><a href="#迭代器和itertools库的使用" class="headerlink" title="迭代器和itertools库的使用"></a>迭代器和itertools库的使用</h1><h2 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h2><p>在Python中，迭代器（Iterator）是一种对象，它可以用来遍历可迭代对象中的元素，如列表、元组、字典等。迭代器对象实现了两个方法：<code>__iter__()</code> 和 <code>__next__()</code>。</p><h3 id="1-自定义迭代器"><a href="#1-自定义迭代器" class="headerlink" title="1.自定义迭代器"></a>1.自定义迭代器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个简单的迭代器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start, end</span>):<br>        self.current = start<br>        self.end = end<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.current &lt; self.end:<br>            result = self.current<br>            self.current += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> StopIteration<br><br><span class="hljs-comment"># 使用迭代器遍历元素</span><br>my_iterator = MyIterator(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_iterator:<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>MyIterator</code> 类实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法。<code>__iter__()</code> 方法返回迭代器对象本身，而 <code>__next__()</code> 方法用于返回迭代器的下一个元素。当没有元素可以返回时，抛出 <code>StopIteration</code> 异常，表示迭代结束。</p><h3 id="2-内置可迭代对象"><a href="#2-内置可迭代对象" class="headerlink" title="2.内置可迭代对象"></a>2.内置可迭代对象</h3><p>除了自定义迭代器类之外，Python内置了一些可迭代对象，比如列表、元组、字典等。你可以使用 <code>iter()</code> 函数获取这些对象的迭代器，然后使用 <code>next()</code> 函数逐个获取元素。</p><p>以下是一个使用内置函数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>my_iterator = <span class="hljs-built_in">iter</span>(my_list)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        item = <span class="hljs-built_in">next</span>(my_iterator)<br>        <span class="hljs-built_in">print</span>(item)<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>注意：在实际编码中，通常使用 <code>for</code> 循环来遍历可迭代对象，而不是直接操作迭代器。<code>for</code> 循环会自动处理迭代器的创建和异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><h3 id="3-使用Iterator泛型来表示迭代器"><a href="#3-使用Iterator泛型来表示迭代器" class="headerlink" title="3.使用Iterator泛型来表示迭代器"></a>3.使用<code>Iterator</code>泛型来表示迭代器</h3><p>在Python中，<code>typing</code>模块提供了类型提示工具，但是它本身并不包含迭代器类型。迭代器类型通常用于表示可以迭代的对象，例如列表、元组和字典等。在<code>typing</code>模块中，你可以使用<code>Iterator</code>泛型来表示迭代器。</p><p>以下是一个简单的例子，演示如何在<code>typing</code>中使用<code>Iterator</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, <span class="hljs-type">List</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterate_list</span>(<span class="hljs-params">input_list: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; Iterator[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># 使用 iter() 函数将列表转换为迭代器</span><br>    iterator = <span class="hljs-built_in">iter</span>(input_list)<br>    <span class="hljs-keyword">return</span> iterator<br><br><span class="hljs-comment"># 示例用法</span><br>my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>my_iterator = iterate_list(my_list)<br><br><span class="hljs-comment"># 使用迭代器遍历元素</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_iterator:<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>iterate_list</code>函数接受一个<code>List[int]</code>类型的参数，并返回一个<code>Iterator[int]</code>类型的迭代器。在函数内部，我们使用<code>iter()</code>函数将传入的列表转换为迭代器，并将其返回。</p><p>需要注意的是，<code>Iterator</code>泛型只是一个类型提示，它在运行时并不会引入新的迭代器对象。它主要用于静态类型检查，以帮助开发者在编写代码时更好地理解和维护代码。</p><p>总的来说，<code>typing</code>模块提供了一些用于类型提示的工具，但在处理实际的迭代器时，主要还是使用Python标准库中的<code>iter</code>和<code>next</code>等迭代器相关的函数。</p><h2 id="2-itertools库的使用"><a href="#2-itertools库的使用" class="headerlink" title="2.itertools库的使用"></a>2.itertools库的使用</h2><p><code>itertools</code> 是 Python 中的一个标准库模块，提供了一组用于高效循环和迭代的工具函数。这些函数返回的是迭代器，而不是将所有元素一次性加载到内存中的序列。这对于处理大型数据集或者生成无限序列非常有用。</p><h3 id="1-itertools-count-start-0-step-1"><a href="#1-itertools-count-start-0-step-1" class="headerlink" title="1.itertools.count(start&#x3D;0, step&#x3D;1)"></a>1.<strong>itertools.count(start&#x3D;0, step&#x3D;1)</strong></h3><p><strong>用法：</strong> 从指定的起始值开始创建一个无限计数器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count<br><br>counter = count(start=<span class="hljs-number">5</span>, step=<span class="hljs-number">2</span>)<br>result = [<span class="hljs-built_in">next</span>(counter) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-built_in">print</span>(result)<br><br>&gt;&gt;&gt;[<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br></code></pre></td></tr></table></figure><h3 id="2-itertools-cycle-iterable"><a href="#2-itertools-cycle-iterable" class="headerlink" title="2.itertools.cycle(iterable)"></a>2.<strong>itertools.cycle(iterable)</strong></h3><p><strong>用法：</strong> 创建一个无限循环的迭代器，重复迭代指定的可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> cycle<br><br>colors = cycle([<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>])<br>result = [<span class="hljs-built_in">next</span>(colors) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>)]<br><span class="hljs-built_in">print</span>(result)<br><br>&gt;&gt;&gt;[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="3-itertools-chain-iterables"><a href="#3-itertools-chain-iterables" class="headerlink" title="3.itertools.chain(*iterables)"></a>3.<strong>itertools.chain(*iterables)</strong></h3><p><strong>用法：</strong> 将多个可迭代对象链接成一个迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain<br><br>list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>tuple1 = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br>result = <span class="hljs-built_in">list</span>(chain(list1, tuple1))<br><span class="hljs-built_in">print</span>(result)<br><br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="4-itertools-combinations-iterable-r"><a href="#4-itertools-combinations-iterable-r" class="headerlink" title="4.itertools.combinations(iterable, r)"></a>4.<strong>itertools.combinations(iterable, r)</strong></h3><p><strong>用法：</strong> 返回可迭代对象中所有长度为 <code>r</code> 的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations<br><br>colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>result = <span class="hljs-built_in">list</span>(combinations(colors, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(result)<br><br>&gt;&gt;&gt;[(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>), (<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>), (<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>)]<br></code></pre></td></tr></table></figure><h3 id="5-itertools-product-iterables-repeat-1"><a href="#5-itertools-product-iterables-repeat-1" class="headerlink" title="5.itertools.product(*iterables, repeat&#x3D;1)"></a>5.<strong>itertools.product(*iterables, repeat&#x3D;1)</strong></h3><p><strong>用法：</strong> 返回可迭代对象的笛卡尔积，可选择重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> product<br><br>dice = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>result = <span class="hljs-built_in">list</span>(product(dice, repeat=<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(result)<br><br>&gt;&gt;&gt;[(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), ..., (<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)]<br></code></pre></td></tr></table></figure><p>这些例子涵盖了一些常见的 <code>itertools</code> 函数，但该模块还提供了其他有用的工具，可以根据具体需求选择合适的函数。</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC库的使用！🍩</title>
    <link href="/2023/12/08/%E7%AE%97%E6%B3%95/python/pythonABC%E5%BA%93/"/>
    <url>/2023/12/08/%E7%AE%97%E6%B3%95/python/pythonABC%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ABC库的使用"><a href="#ABC库的使用" class="headerlink" title="ABC库的使用"></a>ABC库的使用</h1><p>在Python中，<code>abc</code>库是Abstract Base Classes（抽象基类）的缩写。抽象基类是一种用于定义抽象数据类型或接口的方式，它们提供了一种机制来确保子类实现了特定的方法。<code>abc</code>模块提供了用于创建和使用抽象基类的工具。</p><p>以下是一些<code>abc</code>模块中常用的类和函数。</p><h2 id="1-ABC（Abstract-Base-Class）"><a href="#1-ABC（Abstract-Base-Class）" class="headerlink" title="1.ABC（Abstract Base Class）"></a>1.<strong>ABC（Abstract Base Class）</strong></h2><p><code>ABC</code>类是所有抽象基类的基类。通过继承<code>ABC</code>类，可以定义一个抽象基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abstract_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="2-abstractmethod-装饰器"><a href="#2-abstractmethod-装饰器" class="headerlink" title="2.@abstractmethod 装饰器"></a>2.<strong>@abstractmethod 装饰器</strong></h2><p>使用<code>@abstractmethod</code>装饰器可以标记一个方法为抽象方法，该方法必须在子类中实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abstract_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="3-register-方法"><a href="#3-register-方法" class="headerlink" title="3.register 方法"></a>3.<strong>register 方法</strong></h2><p>使用<code>register</code>方法可以将一个类注册为抽象基类的虚拟子类，即使它并不直接继承自该抽象基类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abstract_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># Registering a class as a virtual subclass</span><br>MyConcreteClass = <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;MyConcreteClass&#x27;</span>, (MyAbstractClass,), &#123;&#125;)<br>MyAbstractClass.register(MyConcreteClass)<br></code></pre></td></tr></table></figure><h2 id="4-实例检查"><a href="#4-实例检查" class="headerlink" title="4.实例检查"></a>4.<strong>实例检查</strong></h2><p>使用<code>isinstance</code>函数可以检查一个对象是否是特定抽象基类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abstract_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConcreteClass</span>(<span class="hljs-title class_ inherited__">MyAbstractClass</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">my_abstract_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Concrete class implementation&quot;</span>)<br><br>obj = MyConcreteClass()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, MyAbstractClass))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong><code>abc</code>模块的主要目的是提供一种方式来定义和使用抽象基类，以确保在继承关系中正确地实现了必需的接口或方法。这有助于提高代码的可维护性和可读性。</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python魔术方法使用！🍩</title>
    <link href="/2023/12/07/%E7%AE%97%E6%B3%95/python/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
    <url>/2023/12/07/%E7%AE%97%E6%B3%95/python/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="python魔术方法使用"><a href="#python魔术方法使用" class="headerlink" title="python魔术方法使用"></a>python魔术方法使用</h1><p>所谓魔法函数（Magic Methods），是Python的一种高级语法，允许你在类中自定义函数，并绑定到类的特殊方法中。比如在类A中自定义__str__()函数，则在调用str(A())时，会自动调用__str__()函数，并返回相应的结果。</p><p>Python 的类以其神奇的方法而闻名，通常称为 dunder（双下划线）方法。下面先列举Python里面的魔术方法，挑一些常用的魔术方法进行学习。</p><h2 id="1-魔术方法索引"><a href="#1-魔术方法索引" class="headerlink" title="1.魔术方法索引"></a>1.魔术方法索引</h2><h3 id="1-二元操作符"><a href="#1-二元操作符" class="headerlink" title="1.二元操作符"></a>1.二元操作符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">+<span class="hljs-built_in">object</span>.__add__(self, other)<br>-<span class="hljs-built_in">object</span>.__sub__(self, other)<br>*<span class="hljs-built_in">object</span>.__mul__(self, other)<br>//<span class="hljs-built_in">object</span>.__floordiv__(self, other)<br>/<span class="hljs-built_in">object</span>.__div__(self, other)<br>%<span class="hljs-built_in">object</span>.__mod__(self, other)<br>**<span class="hljs-built_in">object</span>.__pow__(self, other[, modulo])<br>&lt;&lt;<span class="hljs-built_in">object</span>.__lshift__(self, other)<br>&gt;&gt;<span class="hljs-built_in">object</span>.__rshift__(self, other)<br>&amp;<span class="hljs-built_in">object</span>.__and__(self, other)<br>^<span class="hljs-built_in">object</span>.__xor__(self, other)<br>|<span class="hljs-built_in">object</span>.__or__(self, other)<br></code></pre></td></tr></table></figure><h3 id="2-扩展二元操作符"><a href="#2-扩展二元操作符" class="headerlink" title="2.扩展二元操作符"></a>2.扩展二元操作符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">+=<span class="hljs-built_in">object</span>.__iadd__(self, other)<br>-=<span class="hljs-built_in">object</span>.__isub__(self, other)<br>*=<span class="hljs-built_in">object</span>.__imul__(self, other)<br>/=<span class="hljs-built_in">object</span>.__idiv__(self, other)<br>//=<span class="hljs-built_in">object</span>.__ifloordiv__(self, other)<br>%=<span class="hljs-built_in">object</span>.__imod__(self, other)<br>**=<span class="hljs-built_in">object</span>.__ipow__(self, other[, modulo])<br>&lt;&lt;=<span class="hljs-built_in">object</span>.__ilshift__(self, other)<br>&gt;&gt;=<span class="hljs-built_in">object</span>.__irshift__(self, other)<br>&amp;=<span class="hljs-built_in">object</span>.__iand__(self, other)<br>^=<span class="hljs-built_in">object</span>.__ixor__(self, other)<br>|=<span class="hljs-built_in">object</span>.__ior__(self, other)<br></code></pre></td></tr></table></figure><h3 id="3-一元操作符"><a href="#3-一元操作符" class="headerlink" title="3.一元操作符"></a>3.一元操作符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">-<span class="hljs-built_in">object</span>.__neg__(self)<br>+<span class="hljs-built_in">object</span>.__pos__(self)<br><span class="hljs-built_in">abs</span>()<span class="hljs-built_in">object</span>.__abs__(self)<br>~<span class="hljs-built_in">object</span>.__invert__(self)<br><span class="hljs-built_in">complex</span>()<span class="hljs-built_in">object</span>.__complex__(self)<br><span class="hljs-built_in">int</span>()<span class="hljs-built_in">object</span>.__int__(self)<br>long()<span class="hljs-built_in">object</span>.__long__(self)<br><span class="hljs-built_in">float</span>()<span class="hljs-built_in">object</span>.__float__(self)<br><span class="hljs-built_in">oct</span>()<span class="hljs-built_in">object</span>.__oct__(self)<br><span class="hljs-built_in">hex</span>()<span class="hljs-built_in">object</span>.__hex__(self)<br><span class="hljs-built_in">round</span>()<span class="hljs-built_in">object</span>.__round__(self, n)<br>floor()object__floor__(self)<br>ceil()<span class="hljs-built_in">object</span>.__ceil__(self)<br>trunc()<span class="hljs-built_in">object</span>.__trunc__(self)<br></code></pre></td></tr></table></figure><h3 id="4-比较函数"><a href="#4-比较函数" class="headerlink" title="4.比较函数"></a>4.比较函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;<span class="hljs-built_in">object</span>.__lt__(self, other)<br>&lt;=<span class="hljs-built_in">object</span>.__le__(self, other)<br>==<span class="hljs-built_in">object</span>.__eq__(self, other)<br>!=<span class="hljs-built_in">object</span>.__ne__(self, other)<br>&gt;=<span class="hljs-built_in">object</span>.__ge__(self, other)<br>&gt;<span class="hljs-built_in">object</span>.__gt__(self, other)<br></code></pre></td></tr></table></figure><h3 id="5-类的表示、输出"><a href="#5-类的表示、输出" class="headerlink" title="5.类的表示、输出"></a>5.类的表示、输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>()<span class="hljs-built_in">object</span>.__str__(self) <br><span class="hljs-built_in">repr</span>()<span class="hljs-built_in">object</span>.__repr__(self)<br><span class="hljs-built_in">len</span>()<span class="hljs-built_in">object</span>.__len__(self)<br><span class="hljs-built_in">hash</span>()<span class="hljs-built_in">object</span>.__hash__(self) <br><span class="hljs-built_in">bool</span>()<span class="hljs-built_in">object</span>.__nonzero__(self) <br><span class="hljs-built_in">dir</span>()<span class="hljs-built_in">object</span>.__dir__(self)<br>sys.getsizeof()<span class="hljs-built_in">object</span>.__sizeof__(self)<br></code></pre></td></tr></table></figure><h3 id="6-类容器"><a href="#6-类容器" class="headerlink" title="6.类容器"></a>6.类容器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>()<span class="hljs-built_in">object</span>.__len__(self)<br>self[key]<span class="hljs-built_in">object</span>.__getitem__(self, key)<br>self[key] = value<span class="hljs-built_in">object</span>.__setitem__(self, key, value)<br><span class="hljs-keyword">del</span>[key] <span class="hljs-built_in">object</span>.__delitem__(self, key)<br><span class="hljs-built_in">iter</span>()<span class="hljs-built_in">object</span>.__iter__(self)<br><span class="hljs-built_in">reversed</span>()<span class="hljs-built_in">object</span>.__reversed__(self)<br><span class="hljs-keyword">in</span>操作<span class="hljs-built_in">object</span>.__contains__(self, item)<br>字典key不存在时<span class="hljs-built_in">object</span>.__missing__(self, key)<br></code></pre></td></tr></table></figure><h2 id="2-常用魔术方法"><a href="#2-常用魔术方法" class="headerlink" title="2.常用魔术方法"></a>2.常用魔术方法</h2><h3 id="1-init"><a href="#1-init" class="headerlink" title="1.__init__"></a>1.<code>__init__</code></h3><p>它是一个类初始化器。 每当创建一个类的实例时，都会调用其 <code>__init__()</code>方法。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetTest</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Greetings!!&#x27;</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">another_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am another method which is not automatically called&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以看到在实例在创建后会立即调用 <code>__init__</code>。 还可以在初始化期间将参数传递给类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetTest</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Greetings!! &#123;0&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">another_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am another method which is not automatically called&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-getitem"><a href="#2-getitem" class="headerlink" title="2.__getitem__"></a>2.<code>__getitem__</code></h3><p>在类中实现 <code>__getitem__</code> 允许其实例使用<code>[]</code>（索引器）运算符。这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetTest</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.info = &#123;<br>            <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;Yasoob&#x27;</span>,<br>            <span class="hljs-string">&#x27;country&#x27;</span>:<span class="hljs-string">&#x27;Pakistan&#x27;</span>,<br>            <span class="hljs-string">&#x27;number&#x27;</span>:<span class="hljs-number">12345812</span><br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self,i</span>):<br>        <span class="hljs-keyword">return</span> self.info[i]<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>foo = GetTest()<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo[<span class="hljs-string">&#x27;name&#x27;</span>]<br><span class="hljs-string">&#x27;Yasoob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>foo[<span class="hljs-string">&#x27;number&#x27;</span>]<br><span class="hljs-number">12345812</span><br></code></pre></td></tr></table></figure><p>如果没有<code>__getitem__</code>方法，我们会遇到以下错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo[<span class="hljs-string">&#x27;name&#x27;</span>]<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;GetTest&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__getitem__&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-del"><a href="#3-del" class="headerlink" title="3.__del__"></a>3.<code>__del__</code></h3><p><strong>del</strong>()是delete的缩写，这是析构魔术方法。当一块空间没有了任何引用时 默认执行__del__回收这个类地址，一般我们不自定义__del__ 有可能会导致问题。</p><p>触发时机：当对象被内存回收的时候自动触发，有下面两种情况：<br>页面执行完毕回收所有变量<br>当多个对象指向同一地址，所有对象被del的时候<br>功能：对象使用完毕后资源回收<br>参数：一个self接受对象<br>返回值：无</p><blockquote><p>注意：程序自动调用<code>__del__()</code>方法，不需要我们手动调用。</p></blockquote><p>来看例子：现在我们有一个类，在<code>__del__()</code>中打印一些信息，以便我们看到<code>__del__()</code>的调用时机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我嘎嘎能吃&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ohohoh，我被销毁了&quot;</span>)<br></code></pre></td></tr></table></figure><p>现在我们对类实例化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======start======&gt;&quot;</span>)<br>cat1 = Cat()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======ends======&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>程序的输出为：</p><blockquote><p>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<br>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ends&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<br>ohohoh，我被销毁了</p></blockquote><p>出现上面现象的原因是在没有手动执行<code>del</code>的情况下，程序执行结束后自动触发析构方法。</p><p>继续，现在加一个实例化，并且我们<code>del</code>cat1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cat1 = Cat()<br>cat2 = cat1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======start======&gt;&quot;</span>)<br><span class="hljs-keyword">del</span> cat1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======ends======&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>程序的输出为：</p><blockquote><p>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<br>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ends&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<br>ohohoh，我被销毁了</p></blockquote><p>既然我们在start与end中间删除了cat1，为啥程序还是在执行完后触发析构方法？这主要是因为cat2还在继续占用cat1的内存地址，所以会在cat2执行完毕后触发析构方法。</p><p>只要同时删除cat1和cat2，内存地址没有指向的值，这块内存被释放就会触发析构方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">cat1 = Cat()<br>cat2 = cat1<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======start======&gt;&quot;</span>)<br><span class="hljs-keyword">del</span> cat1<br><span class="hljs-keyword">del</span> cat2<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&lt;=======ends======&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>程序的输出为：</p><blockquote><p>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<br>ohohoh，我被销毁了<br>&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ends&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;</p></blockquote><p><strong>注意</strong>：如果这个对象产生了循环引用，并且实现了<code>__del__</code>方法，那么这个对象将得不到释放，从而产生内存泄漏。</p><h3 id="4-call"><a href="#4-call" class="headerlink" title="4.__call__"></a>4.<code>__call__</code></h3><p><strong>call</strong>()方法可以让类的实例具有类似于函数的行为，这进一步模糊了函数和对象之间的概念。</p><p>触发时机：把对象当作函数调用的时候自动触发<br>功能：模拟函数化操作<br>参数：参数不固定，至少一个self参数<br>返回值：看需求<br>其使用方式为：对象后面加括号，触发执行。即：对象() 或者 类()()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call....&#x27;</span>)<br><br><br>a = A()<br>a()  <span class="hljs-comment"># 自动调用__call__()</span><br></code></pre></td></tr></table></figure><p>来看个例子：使用<code>__call__()</code>方法实现斐波那契数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fibonacci</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, num</span>):<br>        a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>        lst = []<br>        <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">2</span>:<br>            lst.append(a)<br>            lst.append(b)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>                lst.append(a)<br>                a, b = b, a + b<br>        <span class="hljs-keyword">return</span> lst<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>f = Fibonacci()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(f(<span class="hljs-number">5</span>))<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h3 id="5-slots"><a href="#5-slots" class="headerlink" title="5.__slots__"></a>5.<code>__slots__</code></h3><p>Python是一门动态语言，这使得我们可以在程序运行的时候给对象绑定新的属性或方法，这就是动态语言的灵活性。</p><p>我们先定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br></code></pre></td></tr></table></figure><p>然后创建一个实例并<strong>动态为这个实例绑定一个属性和方法</strong>，但是为实例绑定的属性和方法对另一个实例并不起作用，如果需要应用在多个实例上，则需要将其绑定到类上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I can fly~&#x27;</span>)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1 = Person(<span class="hljs-string">&#x27;王大锤&#x27;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p2 = Person(<span class="hljs-string">&#x27;爱丽丝&#x27;</span>, <span class="hljs-number">16</span>)<br>&gt;&gt;&gt;<br><span class="hljs-comment"># 动态绑定属性和方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.fly = MethodType(fly, p1)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.fly()<br>I can fly~<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p2.fly()  <span class="hljs-comment"># p1绑定的属性和方法对p2无效</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;D:\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py&quot;</span>, line <span class="hljs-number">3331</span>, <span class="hljs-keyword">in</span> run_code<br>    <span class="hljs-built_in">exec</span>(code_obj, self.user_global_ns, self.user_ns)<br>  File <span class="hljs-string">&quot;&lt;ipython-input-31-07b12cf8c526&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    p2.fly()<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;fly&#x27;</span><br></code></pre></td></tr></table></figure><p>动态绑定确实方便，但是如果我们需要限定自定义类型的对象只能绑定某些属性要怎么办呢？<code>__slots__</code>可以解决这个需求。</p><p>定义类的时候，可以定义一个特殊的<code>__slots__</code>变量，来限制该类实例能添加的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __slots__ = (<span class="hljs-string">&#x27;_name&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>, <span class="hljs-string">&#x27;_gender&#x27;</span>)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self._name = name<br>        self._age = age<br></code></pre></td></tr></table></figure><p>实例就不能再添加不在限定范围内的属性了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person(<span class="hljs-string">&#x27;陆七岁&#x27;</span>, <span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p._gender = <span class="hljs-string">&#x27;男&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p._gender<br><span class="hljs-string">&#x27;男&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p._school = <span class="hljs-string">&#x27;Q小学&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;D:\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py&quot;</span>, line <span class="hljs-number">3331</span>, <span class="hljs-keyword">in</span> run_code<br>    <span class="hljs-built_in">exec</span>(code_obj, self.user_global_ns, self.user_ns)<br>  File <span class="hljs-string">&quot;&lt;ipython-input-36-c90af696bffa&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    p._school = <span class="hljs-string">&#x27;Q小学&#x27;</span><br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;_school&#x27;</span><br></code></pre></td></tr></table></figure><p>但要注意的是，<strong>限制只是针对实例</strong>，<strong>类本身并不会被限制</strong>。怎么理解能？就是我们仍然可以通过类去添加属性或方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Person._school = <span class="hljs-string">&#x27;Q小学&#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>Person._school<br><span class="hljs-string">&#x27;Q小学&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1._school<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;D:\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py&quot;</span>, line <span class="hljs-number">3331</span>, <span class="hljs-keyword">in</span> run_code<br>    <span class="hljs-built_in">exec</span>(code_obj, self.user_global_ns, self.user_ns)<br>  File <span class="hljs-string">&quot;&lt;ipython-input-38-f12357d4471f&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    p1._school<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;_school&#x27;</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>__slots__是针对类实例的限制，要添加属性或方法仍可以通过类去添加；<br>__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</p><h3 id="6-str"><a href="#6-str" class="headerlink" title="6.__str__"></a>6.<code>__str__</code></h3><p><code>__str__()</code>方法可以改变对象的字符串显示。在打印某个对象的时候，会调用这个对象的<code>__str__</code>方法，打印这个方法的返回值。</p><ul><li>触发时机：使用<code>print(对象)</code>或<code>str(对象)</code>时触发。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sex</span>):<br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;我是一只可爱的小<span class="hljs-subst">&#123;self.sex&#125;</span>猫咪，我的名字是<span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span><br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat = Cat(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-string">&quot;公&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(cat)<br>我是一只可爱的小公猫咪，我的名字是小白<br></code></pre></td></tr></table></figure><h3 id="7-repr"><a href="#7-repr" class="headerlink" title="7.__repr__"></a>7.<code>__repr__</code></h3><p><strong>repr</strong>()方法可以改变对象的字符串显示。__repr__魔术方法是用来表述某个对象在内存中的展示形式。如果在终端直接输入一个对象，然后按回车，那么将会执行这个对象的__repr__方法。</p><ul><li>此方法是<code>__str__()</code>的“备胎”，如果找不到<code>__str__()</code>就会找<code>__repr__()</code>方法。</li><li><code>%r</code>默认调用的是<code>__repr__()</code>方法，<code>%s</code>调用<code>__str__()</code>方法</li><li><code>repr()</code>方法默认调用<code>__repr__()</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        msg = <span class="hljs-string">&#x27;name:&#123;&#125;,age:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, self.age)<br>        <span class="hljs-keyword">return</span> msg<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        msg = <span class="hljs-string">&#x27;name---&gt;&#123;&#125;,age---&gt;&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, self.age)<br>        <span class="hljs-keyword">return</span> msg<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = A(<span class="hljs-string">&#x27;za&#x27;</span>, <span class="hljs-number">34</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s&#x27;</span> % a) <br>name:za, age:<span class="hljs-number">34</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%r&#x27;</span> % a)  <span class="hljs-comment"># 用 %r,默认调用__repr__()方法</span><br>name--&gt;za, age--&gt;<span class="hljs-number">34</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 有__str__()方法就会调用__str__()方法，没有就调用__repr__()方法</span><br>name:za, age:<span class="hljs-number">34</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(a))  <span class="hljs-comment"># repr()方法默认调用__repr__()方法</span><br>name--&gt;za, age--&gt;<span class="hljs-number">34</span><br></code></pre></td></tr></table></figure><p>注意：如果将几个对象扔到一个容器中（比如：列表），那么在打印这个容器的时候，会依次调用这个容器中的元素的<code>__repr__</code>方法。如果没有实现这个<code>__repr__</code>方法，那么得到的将是一个类名+地址的形式，这种形式的是不好理解的。</p><h3 id="8-new"><a href="#8-new" class="headerlink" title="8.__new__"></a>8.<code>__new__</code></h3><p>触发时机： 在实例化对时触发<br>参数：至少一个cls 接收当前类<br>返回值：必须返回一个对象实例<br>作用：实例化对象</p><blockquote><p>注意：实例化对象是<code>Object</code>类底层实现，其他类继承了<code>Object</code>的<code>__new__</code>才能够实现实例化对象。</p></blockquote><p>第一个例子：查看<code>__new__</code>方法的执行时机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__init__(): 我也被调用啦~&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):  <span class="hljs-comment"># 重写后,不再创建对象</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__new__(): 哈哈我被调用啦~&#x27;</span>)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>per = Person()<br>__new__(): 哈哈我被调用啦~<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(per)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><code>None</code>说明没有创建对象，因为我们重写了<code>__new__</code>方法，<code>__new__</code>方法不再具有创建对象的功能，只有打印的功能。</p><p>第二个例子：调用父类的<code>__new__</code>方法，创建当前对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__init__(): 我也被调用啦~&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__new__(): 哈哈我被调用啦~&#x27;</span>)<br>        ret = <span class="hljs-built_in">super</span>().__new__(cls)  <span class="hljs-comment"># 调用父类object的__new__方法创建对象</span><br>        <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>per = Person()<br>__new__(): 哈哈我被调用啦~<br>__init__(): 我也被调用啦~<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(per)<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000020FA3892848</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="9-eq"><a href="#9-eq" class="headerlink" title="9.__eq__"></a>9.<code>__eq__</code></h3><p>说到<code>__eq__()</code>魔法方法，就必须提到Python中的<code>is</code>和<code>==</code>。先来看看这两者的区别：</p><ul><li><code>is</code> 比较两个对象的 <code>id </code>值是否相等，是否指向同一个内存地址；</li><li><code>==</code> 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。</li></ul><p><code>==</code>在比较类时，会默认调用<code>object.__eq__</code>方法，默认比较两个对象的地址（id）。</p><p>第一个例子：<code>list1</code>和<code>list2</code>的值相同，但<code>id</code>不同，来看看<code>is</code>和<code>==</code>的区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>list2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(list1)) <br><span class="hljs-number">1759352803720</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(list2))<br><span class="hljs-number">1759352804232</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(list1 == list2)  <br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(list1 <span class="hljs-keyword">is</span> list2)  <br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>第二个例子：类的比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sex</span>):<br>        self.name = name<br>        self.sex = sex<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>c1 = Cat(<span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c2 = Cat(<span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1.__dict__)  <br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c2.__dict__) <br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1 == c2)  <span class="hljs-comment"># ==比较时默认调用object.__eq__方法，默认比较两个对象的地址</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1 <span class="hljs-keyword">is</span> c2) <br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>重写<code>__eq__()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sex</span>):<br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.__dict__ == other.__dict__<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>c1 = Cat(<span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c2 = Cat(<span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1.__dict__)  <br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c2.__dict__) <br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;小白&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1 == c2)  <span class="hljs-comment"># ==比较时默认调用object.__eq__方法，默认比较两个对象的地址</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1 <span class="hljs-keyword">is</span> c2) <br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="10-bool"><a href="#10-bool" class="headerlink" title="10.__bool__"></a>10.<code>__bool__</code></h3><ul><li>触发时机：使用<code>bool(对象)</code>的时候自动触发</li><li>功能：强转对象</li><li>参数：一个<code>self</code>接受当前对象</li><li>返回值：必须是布尔类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, sex</span>):<br>        self.name = name<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat = Cat(<span class="hljs-string">&quot;小白&quot;</span>, <span class="hljs-string">&quot;公&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(cat))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="11-add"><a href="#11-add" class="headerlink" title="11.__add__"></a>11.<code>__add__</code></h3><p><code>__add__</code>与<code>__radd__</code>都是做加法，只是加法的顺序不一样，会调用不同的魔法函数。</p><ul><li>触发时机：使用对象进行运算相加的时候自动触发</li><li>功能：对象运算</li><li>参数：两个对象参数</li><li>返回值：运算后的值</li></ul><p>对象在加号的左侧时，自动调用<code>__add__()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br>        self.num = num<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):  <span class="hljs-comment"># 对象在加号+的左侧时,自动触发</span><br>        <span class="hljs-keyword">return</span> self.num + other<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>value = Sum(<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>res = value + <span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(res)<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>对象在加号的右侧时，自动调用<code>__radd__()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br>        self.num = num<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__radd__</span>(<span class="hljs-params">self, other</span>):  <br>        <span class="hljs-keyword">return</span> self.num + other<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>value = Sum(<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>res = <span class="hljs-number">10</span> + value<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(res)<br><span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum1</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br>        self.num = num<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.num + other<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sum2</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num</span>):<br>        self.num = num<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__radd__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.num * <span class="hljs-number">2</span> + other<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>value1 = Sum1(<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>value2 = Sum2(<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>res = value1 + value2<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>分析：首先将<code>res=value1+value2</code>传入<code>Sum1</code>中，得出值<code>res=10+value2</code>，再将<code>res=10+value2</code>传入<code>Sum2</code>中，所以<code>res=14+10=24</code>。</p><h3 id="12-len"><a href="#12-len" class="headerlink" title="12.__len__"></a>12.<code>__len__</code></h3><ul><li>触发时机：使用len对象的时候自动触发</li><li>功能：用于检测对象中或者类中成员个数</li><li>参数：一个self接收当前对象</li><li>返回值：必须是<strong>整型</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.num = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x</span>):<br>        self.num.append(x)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.num)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>l = <span class="hljs-type">List</span>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>l.add(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(l))<br></code></pre></td></tr></table></figure><h3 id="13-dict"><a href="#13-dict" class="headerlink" title="13.__dict__"></a>13.<code>__dict__</code></h3><p>获取类或对象的的<strong>内部成员结构</strong>。主要用来获取用户自定义的属性，以及这个属性对应的值。返回的是一个<strong>字典</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>():<br>    name1 = <span class="hljs-string">&quot;Lsir&quot;</span><br>    name2 = <span class="hljs-string">&quot;Wsir&quot;</span><br>    name3 = <span class="hljs-string">&quot;Zsir&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">task1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;task1&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">task2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tesk2&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">task3</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;task3&quot;</span>)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(MyClass.__dict__)<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name1&#x27;</span>: <span class="hljs-string">&#x27;Lsir&#x27;</span>, <span class="hljs-string">&#x27;name2&#x27;</span>: <span class="hljs-string">&#x27;Wsir&#x27;</span>, <span class="hljs-string">&#x27;name3&#x27;</span>: <span class="hljs-string">&#x27;Zsir&#x27;</span>, <span class="hljs-string">&#x27;task1&#x27;</span>: &lt;function MyClass.task1 at <span class="hljs-number">0x0000020C16385558</span>&gt;, <span class="hljs-string">&#x27;task2&#x27;</span>: &lt;function MyClass.task2 at <span class="hljs-number">0x0000020C16385D38</span>&gt;, <span class="hljs-string">&#x27;task3&#x27;</span>: &lt;function MyClass.task3 at <span class="hljs-number">0x0000020C16385708</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;MyClass&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;MyClass&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><p>和<code>dir</code>函数做一个区分。<code>dir</code>函数返回的是这个对象上拥有的所有属性，包括Python内置的属性和用户自己添加的，并且只是获取属性名字，不会获取这个属性对应的值。</p><h3 id="14-doc"><a href="#14-doc" class="headerlink" title="14.__doc__"></a>14.<code>__doc__</code></h3><p>获取类或对象内部文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        我是一个类，这里说明一些有用的信息</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-built_in">print</span>(MyClass.__doc__)<br><br>        我是一个类，这里说明一些有用的信息<br>    <br></code></pre></td></tr></table></figure><h3 id="15-name"><a href="#15-name" class="headerlink" title="15.__name__"></a>15.<code>__name__</code></h3><p>获取类名或函数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">task1</span>(<span class="hljs-params">self, func1</span>):<br>        <span class="hljs-built_in">print</span>(func1.__name__)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是func1函数&quot;</span>)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj = MyClass()<br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.task1(func)<br>func<br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.task1(Class1)<br>Class1<br></code></pre></td></tr></table></figure><h3 id="16-class"><a href="#16-class" class="headerlink" title="16.__class__"></a>16.<code>__class__</code></h3><p>获取当前对象获取的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj = Class1()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(obj.__class__)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Class1&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(obj.__class__.__name__)<br>Class1<br></code></pre></td></tr></table></figure><h3 id="17-bases"><a href="#17-bases" class="headerlink" title="17.__bases__"></a>17.<code>__bases__</code></h3><p>获取一个类直接继承的所有父类，返回元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class2</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(Class1, Class2):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(MyClass.__bases__)<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Class1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Class2&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="18-getattr"><a href="#18-getattr" class="headerlink" title="18.__getattr__"></a>18.<code>__getattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:<br>    n = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    z = <span class="hljs-number">6</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.x, self.y)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.x<br><span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.z<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.n<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.t<br><span class="hljs-string">&#x27;t&#x27;</span><br></code></pre></td></tr></table></figure><p>实例属性会按照<strong>继承关系</strong>寻找，如果找不到，就会执行<code>__getattr__()</code>方法，如果没有这个方法，就会抛出<code>AttributeError</code>异常标识找不到属性。</p><h3 id="19-setattr"><a href="#19-setattr" class="headerlink" title="19.__setattr__"></a>19.<code>__setattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:<br>    n = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    z = <span class="hljs-number">6</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.x, self.y)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-built_in">print</span>(key, value)<br>        <br><span class="hljs-comment"># --------------------------------------------------</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1 = Point(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>x <span class="hljs-number">4</span><br>y <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.x)<br>x<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.z)<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.n)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.t)<br>t<br><span class="hljs-comment"># --------------------------------------------------</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.x = <span class="hljs-number">50</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.x)<br>x<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.__dict__)<br>&#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.__dict__[<span class="hljs-string">&#x27;x&#x27;</span>] = <span class="hljs-number">60</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.__dict__)<br>&#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">60</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>p1.x<br><span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>实例通过<code>.</code>点号设置属性，例如<code>self.x=x</code>，就会调用<code>__setattr__()</code>，属性要加到实例的<code>__dict__</code>中，就需要自己完成。</p><p><code>setattr()</code>方法，可以拦截堆实例属性的增加，修改操作，如果要设置生效，需要自己操作实例的<code>__dict__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:<br>    n = <span class="hljs-number">200</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    z = <span class="hljs-number">100</span><br>    d = &#123;&#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        <span class="hljs-built_in">setattr</span>(self, <span class="hljs-string">&#x27;y&#x27;</span>, y)<br>        self.__dict__[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">5</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(item)<br>        <span class="hljs-keyword">return</span> self.d[item]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-built_in">print</span>(key, value)<br>        self.d[key] = value<br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>a = A(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>x <span class="hljs-number">4</span><br>y <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.__dict__)<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(A.__dict__)<br>A.__dict__<br>mappingproxy(&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>,<br>              <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">100</span>,<br>              <span class="hljs-string">&#x27;d&#x27;</span>: &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-number">5</span>&#125;,<br>              <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function __main__.A.__init__(self, x, y)&gt;,<br>              <span class="hljs-string">&#x27;__getattr__&#x27;</span>: &lt;function __main__.A.__getattr__(self, item)&gt;,<br>              <span class="hljs-string">&#x27;__setattr__&#x27;</span>: &lt;function __main__.A.__setattr__(self, key, value)&gt;,<br>              <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.x, a.y)<br>x<br>y<br><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a.a)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="20-delattr"><a href="#20-delattr" class="headerlink" title="20.__delattr__"></a>20.<code>__delattr__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:<br>    z = <span class="hljs-number">5</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(item)<br>        p = Point(<span class="hljs-number">14</span>, <span class="hljs-number">5</span>)<br><br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> p.x<br>x<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.z=<span class="hljs-number">15</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> p.z<br>z<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> p.Z        <br>Z<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Point.__dict__)<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Point.__init__ at <span class="hljs-number">0x0000019E93B01318</span>&gt;, <span class="hljs-string">&#x27;__delattr__&#x27;</span>: &lt;function Point.__delattr__ at <span class="hljs-number">0x0000019E93B013A8</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Point&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Point&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="21-getattribute"><a href="#21-getattribute" class="headerlink" title="21.__getattribute__"></a>21.<code>__getattribute__</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:<br>    n = <span class="hljs-number">0</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Base</span>):<br>    z = <span class="hljs-number">6</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x<br>        self.y = y<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> item<br>     <br><span class="hljs-meta">&gt;&gt;&gt; </span>p1 = Point(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.__dict__)<br>__dict__<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.x)<br>x<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.z)<br>z<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.n)<br>n<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p1.t)<br>t<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Point.__dict__)<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Point.__init__ at <span class="hljs-number">0x000001F5EB7063A8</span>&gt;, <span class="hljs-string">&#x27;__getattr__&#x27;</span>: &lt;function Point.__getattr__ at <span class="hljs-number">0x000001F5EB706558</span>&gt;, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>: &lt;function Point.__getattribute__ at <span class="hljs-number">0x000001F5EB706168</span>&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Point.z)<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>实例的所有的属性访问，第一个都会调用__getattribute__方法，它阻止了属性的查找，该方法应该返回值或者抛出一个AttributeError异常。</p><ul><li>该方法的返回值将作为属性查找的结果。</li><li>如果抛出<code>AttributeError</code>异常，则会直接调用<code>__getattr__</code>方法，因为属性没有找到，<code>__getattribute__</code>方法中为了避免在该方法中无限递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性。</li></ul><p>需要注意的是，除非明确知道__getattrtbute__方法用来做什么，否则不要使用。</p><h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h2><h3 id="3-1-setitem和getitem"><a href="#3-1-setitem和getitem" class="headerlink" title="3.1 setitem和getitem"></a>3.1 setitem和getitem</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.data = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        self.data[key] = value<br><br><span class="hljs-comment"># 创建 MyClass 实例</span><br>obj = MyClass()<br><br><span class="hljs-comment"># 使用 square bracket notation 进行赋值</span><br>obj[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;John&#x27;</span><br>obj[<span class="hljs-string">&#x27;age&#x27;</span>] = <span class="hljs-number">30</span><br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(obj.data)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>__setitem__</code> 方法允许我们使用类似字典赋值的语法（<code>obj[&#39;name&#39;] = &#39;John&#39;</code>）将数据存储到 <code>MyClass</code> 实例中。在这里，<code>obj.data</code> 将包含键值对 <code>&#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30&#125;</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.data.get(item, <span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># 创建 MyClass 实例</span><br>obj = MyClass()<br><br><span class="hljs-comment"># 使用方括号表示法获取元素</span><br>name = obj[<span class="hljs-string">&#x27;name&#x27;</span>]<br>age = obj[<span class="hljs-string">&#x27;age&#x27;</span>]<br>unknown_key = obj[<span class="hljs-string">&#x27;unknown_key&#x27;</span>]<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(name)  <span class="hljs-comment"># 输出: John</span><br><span class="hljs-built_in">print</span>(age)   <span class="hljs-comment"># 输出: 30</span><br><span class="hljs-built_in">print</span>(unknown_key)  <span class="hljs-comment"># 输出: None，因为键 &#x27;unknown_key&#x27; 在 data 中不存在</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>__getitem__</code> 方法允许我们使用方括号表示法获取 <code>MyClass</code> 实例中的元素。如果请求的键在 <code>self.data</code> 字典中存在，则返回对应的值；否则返回 <code>None</code>。</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dataclasses库的使用！🍩</title>
    <link href="/2023/12/07/%E7%AE%97%E6%B3%95/python/python%E4%B8%ADDataclasses%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/07/%E7%AE%97%E6%B3%95/python/python%E4%B8%ADDataclasses%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="dataclasses库的使用"><a href="#dataclasses库的使用" class="headerlink" title="dataclasses库的使用"></a>dataclasses库的使用</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><code>Dataclasses</code>是一些适合于存储数据对象（data object）的Python类。</p><p>他们存储并表示特定的数据类型。例如：一个数字。</p><p>并且他们能够被用于和同类型的其他对象进行比较。</p><h2 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h2><p>Python3.7 提供了一个装饰器<code>dataclass</code>，用以把一个类转化为<code>dataclass</code>。</p><p>你需要做的就是把类包裹进装饰器里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br> ...<br></code></pre></td></tr></table></figure><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h2><p>正常的初始化过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        self.val = val<br><span class="hljs-meta">&gt;&gt;&gt; </span>one = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>one.val<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>用<code>dataclass</code>是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val:<span class="hljs-built_in">int</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>one = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>one.val<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>以下是<code>dataclass</code>装饰器带来的变化：</p><ol><li>无需定义<code>__init__</code>，然后将值赋给<code>self</code>，<code>dataclass</code>负责处理它</li><li>我们以更加易读的方式预先定义了成员属性，以及<strong>类型提示</strong>。我们现在立即能知道<code>val</code>是<code>int</code>类型。这无疑比一般定义类成员的方式更具可读性。</li></ol><p>它也可以定义默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val:<span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="4-表示"><a href="#4-表示" class="headerlink" title="4.表示"></a>4.表示</h2><p>对象表示指的是对象的一个有意义的字符串表示，它在调试时非常有用。</p><p>默认的 Python 对象表示不是很直观：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val = <span class="hljs-number">0</span></span>):<br>    self.val = val<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-meta">&gt;&gt;&gt; </span>&lt;__main__.Number <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7ff395b2ccc0</span>&gt;<br></code></pre></td></tr></table></figure><p>这让我们无法知悉对象的作用，并且会导致糟糕的调试体验。</p><p>一个有意义的表示可以通过在类中定义一个<code>__repr__</code>方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self.val<br></code></pre></td></tr></table></figure><p>现在我们得到这个对象有意义的表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>dataclass</code>会自动添加一个<code>__repr__</code>函数，这样我们就不必手动实现它了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-meta">&gt;&gt;&gt; </span>Number(val = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="5-数据比较"><a href="#5-数据比较" class="headerlink" title="5.数据比较"></a>5.数据比较</h2><p>通常，数据对象之间需要相互比较。</p><p>两个对象<code>a</code>和<code>b</code>之间的比较通常包括以下操作：</p><ul><li>a &lt; b</li><li>a &gt; b</li><li>a &#x3D;&#x3D; b</li><li>a &gt;&#x3D; b</li><li>a &lt;&#x3D; b</li></ul><p>在 Python 中，能够在可以执行上述操作的类中定义方法。为了简单起见，只展示<code>==</code>和<code>&lt;</code>的实现。</p><p>通常这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"> self, val = <span class="hljs-number">0</span></span>):<br>       self.val = val<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.val == other.val<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.val &lt; other.val<br></code></pre></td></tr></table></figure><p>使用<code>dataclass</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">order = <span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们不需要定义<code>__eq__</code>和<code>__lt__</code>方法，因为当<code>order = True</code>被调用时，<code>dataclass 装饰器</code>会自动将它们添加到我们的类定义中。</p><p>当你使用<code>dataclass</code>时，它会在类定义中添加函数<code>__eq__</code>和<code>__lt__</code>。</p><p>生成<code>__eq__</code>函数的 dataclass 类会比较两个属性构成的元组，一个由自己属性构成的，另一个由同类的其他实例的属性构成。在我们的例子中，自动生成的<code>__eq__</code>函数相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>    <span class="hljs-keyword">return</span> (self.val,) == (other.val,)<br></code></pre></td></tr></table></figure><p>让我们来看一个更详细的例子：</p><p>我们会编写一个<code>dataclass</code>类<code>Person</code>来保存<code>name</code>和<code>age</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">order = <span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    name: <span class="hljs-built_in">str</span><br>    age:<span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>自动生成的<code>__eq__</code>方法等同于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>    <span class="hljs-keyword">return</span> (self.name, self.age) == ( other.name, other.age)<br></code></pre></td></tr></table></figure><p>请注意属性的顺序。它们总是按照你在<code>dataclass</code>类中定义的顺序生成。</p><p>同样，等效的<code>__le__</code>函数类似于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>    <span class="hljs-keyword">return</span> (self.name, self.age) &lt;= (other.name, other.age)<br></code></pre></td></tr></table></figure><h2 id="6-dataclass-作为一个可调用的装饰器"><a href="#6-dataclass-作为一个可调用的装饰器" class="headerlink" title="6.dataclass 作为一个可调用的装饰器"></a>6.dataclass 作为一个可调用的装饰器</h2><p>定义所有的<strong>魔法方法</strong>（下一篇详细介绍）并不总是值得的。你的用例可能只包括存储值和检查相等性。因此，你只需定义<code>__init__</code>和<code>__eq__</code>方法。如果我们可以告诉装饰器不生成其他方法，那么它会减少一些开销，并且我们将在数据对象上有正确的操作。</p><p>幸运的是，这可以通过将<code>dataclass</code>装饰器作为可调用对象来实现。</p><p>装饰器可以用作具有如下参数的可调用对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">init=<span class="hljs-literal">True</span>, <span class="hljs-built_in">repr</span>=<span class="hljs-literal">True</span>, eq=<span class="hljs-literal">True</span>, order=<span class="hljs-literal">False</span>, unsafe_hash=<span class="hljs-literal">False</span>, frozen=<span class="hljs-literal">False</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<br> …<br></code></pre></td></tr></table></figure><ul><li><code>init</code>：默认将生成<code>__init__</code>方法。如果传入<code>False</code>，那么该类将不会有<code>__init__</code>方法。</li><li><code>repr</code>：<code>__repr__</code>方法默认生成。如果传入<code>False</code>，那么该类将不会有<code>__repr__</code>方法。</li><li><code>eq</code>：默认将生成<code>__eq__</code>方法。如果传入<code>False</code>，那么<code>__eq__</code>方法将不会被<code>dataclass</code>添加，但默认为<code>object.__eq__</code>。</li><li><code>order</code>：默认将生成<code>__gt__</code>、<code>__ge__</code>、<code>__lt__</code>、<code>__le__</code>方法。如果传入<code>False</code>，则省略它们。<br>我们在接下来会讨论<code>frozen</code>。由于<code>unsafe_hash</code>参数复杂的用例，它值得单独发布一篇文章。</li></ul><p>现在回到我们的用例，以下是我们需要的：</p><ol><li><strong>init</strong></li><li><strong>eq</strong></li></ol><p>默认会生成这些函数，因此我们需要的是不生成其他函数。那么我们该怎么做呢？很简单，只需将相关参数作为<code>false</code>传入给生成器即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params"><span class="hljs-built_in">repr</span> = <span class="hljs-literal">False</span></span>) </span><span class="hljs-comment"># order, unsafe_hash and frozen are False</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-meta">&gt;&gt;&gt; </span>&lt;__main__.Number <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7ff395afe898</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = Number(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>c = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a &lt; b<br><span class="hljs-comment">#下列错误表示 &lt; 操作没有实现</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Traceback (most recent call last):<br> File “&lt;stdin&gt;”, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: ‘&lt;’ <span class="hljs-keyword">not</span> supported between instances of ‘Number’ <span class="hljs-keyword">and</span> ‘Number’<br></code></pre></td></tr></table></figure><h2 id="7-Frozen（不可变）-实例"><a href="#7-Frozen（不可变）-实例" class="headerlink" title="7.Frozen（不可变） 实例"></a>7.Frozen（不可变） 实例</h2><p>Frozen 实例是在初始化对象后无法修改其属性的对象。</p><blockquote><p>无法创建真正不可变的 Python 对象</p></blockquote><p>以下是我们期望不可变对象能够做到的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">10</span>) <span class="hljs-comment">#Assuming Number class is immutable</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.val = <span class="hljs-number">10</span> <span class="hljs-comment"># Raises Error</span><br></code></pre></td></tr></table></figure><p>有了<code>dataclass</code>，就可以通过使用<code>dataclass</code>装饰器作为可调用对象配合参数<code>frozen=True</code>来定义一个<code>frozen</code>对象。</p><p>当实例化一个<code>frozen</code>对象时，任何企图修改对象属性的行为都会引发<code>FrozenInstanceError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">frozen = <span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>:<br>    val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.val<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.val = <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>Traceback (most recent call last):<br> File “&lt;stdin&gt;”, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br> File “&lt;string&gt;”, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> __setattr__<br>dataclasses.FrozenInstanceError: cannot assign to field ‘val’<br></code></pre></td></tr></table></figure><p>因此，一个<code>frozen 实例</code>是一种很好方式来存储：</p><ul><li>常数</li><li>设置<br>这些通常不会在应用程序的生命周期内发生变化，任何企图修改它们的行为都应该被禁止。</li></ul><h2 id="8-后期初始化处理"><a href="#8-后期初始化处理" class="headerlink" title="8.后期初始化处理"></a>8.后期初始化处理</h2><p>有了<code>dataclass</code>，需要定义一个<code>__init__</code>方法来将变量赋给<code>self</code>这种初始化操作已经得到了处理。但是我们失去了在变量被赋值之后立即需要的函数调用或处理的灵活性。</p><p>让我们来讨论一个用例，在这个用例中，我们定义一个<code>Float</code>类来包含浮点数，然后在初始化之后立即计算整数和小数部分。</p><p>通常是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Float</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val = <span class="hljs-number">0</span></span>):<br>        self.val = val<br>        self.process()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">self</span>):<br>        self.decimal, self.integer = math.modf(self.val)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Float( <span class="hljs-number">2.2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.decimal<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.2000</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.integer<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>幸运的是，使用<strong>post_init</strong>方法已经能够处理后期初始化操作。</p><p>生成的<code>__init__</code>方法在返回之前调用<code>__post_init__</code>返回。因此，可以在函数中进行任何处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FloatNumber</span>:<br>    val: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">self</span>):<br>        self.decimal, self.integer = math.modf(self.val)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">2.2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.val<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2.2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.integer<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.decimal<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9.继承"></a>9.继承</h2><p><code>Dataclasses</code>支持继承，就像普通的<code>Python</code>类一样。</p><p>因此，父类中定义的属性将在子类中可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    age: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span><br>    name: <span class="hljs-built_in">str</span><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    grade: <span class="hljs-built_in">int</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-number">12</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;John Doe&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.grade<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>请注意，<code>Student</code>的参数是在类中定义的字段的顺序。</p><p>继承过程中<code>__post_init__</code>的行为是怎样的？</p><p>由于<code>__post_init__</code>只是另一个函数，因此必须以传统方式调用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    a: <span class="hljs-built_in">int</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    b: <span class="hljs-built_in">int</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = B(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>B<br></code></pre></td></tr></table></figure><p>在上面的例子中，只有<code>B</code>的<code>__post_init__</code>被调用，那么我们如何调用<code>A</code>的<code>__post_init__</code>呢？</p><p>因为它是父类的函数，所以可以用<code>super</code>来调用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    b: <span class="hljs-built_in">int</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__post_init__() <span class="hljs-comment"># 调用 A 的 post init</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = B(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>A<br>    B<br></code></pre></td></tr></table></figure><h2 id="10-field"><a href="#10-field" class="headerlink" title="10.field"></a>10.field</h2><p>我们已经知道<code>Dataclasses</code>会生成他们自身的<code>__init__</code>方法。它同时把初始化的值赋给这些字段。</p><ul><li>变量名</li><li>数据类型</li></ul><p>这些内容仅给我们有限的<code>dataclass</code>字段使用范围。让我们讨论一下这些局限性，以及它们如何通过<code>dataclass.field</code>被解决。</p><h3 id="1-复合初始化"><a href="#1-复合初始化" class="headerlink" title="1.复合初始化"></a>1.复合初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_random_marks</span>():<br>    retun [random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    marks:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__post_init__</span>(<span class="hljs-params">seif</span>):<br>    self.marks = get_random_marks() <span class="hljs-comment">#Assign random speeds</span><br><br>&gt;&gt;&gt;a= Student()<br>&gt;&gt;&gt;a.marks<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>数据类<code>Student</code>产生了一个名为<code>marks</code>的列表。我们不传递<code>marks</code>的值，而是使用<code>__post_init__</code>方法初始化。这是我们定义的单一属性。此外，我们必须在<code>__post_init__</code>里调用<code>get_random_marks</code>函数。这些工作是额外的。</p><p>辛运的是，<code>Python</code>为我们提供了一个解决方案。我们可以使用<code>dataclasses.field</code>来定制化<code>dataclass</code>字段的行为以及它们在<code>dataclass</code>的影响。</p><p>仍然是上述的使用情形，让我们从<code>__post_init__</code>里去除<code>get_random_marks</code>的调用。以下是使用<code>dataclasses.field</code>的情形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> field<br><span class="hljs-meta">@dataclass</span><br>c1ass Student:<br>marks:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]= field(default_factory=get_random_marks)<br>&gt;&gt;&gt;s = Student()<br>&gt;&gt;&gt;s.marks<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p><code>dataclasses.field</code>接受了一个名为<code>default_factory</code>的参数，它的作用是：如果在创建对象时没有赋值，则使用该方法初始化该字段。</p><p><code>default_factory</code>必须是一个可以调用的无参数方法（通常为一个函数）。</p><h3 id="2-使用全部字段进行数据比较"><a href="#2-使用全部字段进行数据比较" class="headerlink" title="2.使用全部字段进行数据比较"></a>2.使用全部字段进行数据比较</h3><p>我们了解到，<code>dataclass</code>能够自动生成<code>&lt;</code>,<code>=,&gt;</code>,<code>&lt;=</code>和<code>&gt;=</code>这些比较方法。但是这些比较方法的一个缺陷是，它们使用类中的所有字段进行比较，而这种情况往往不常见。更经常地，这种比较方法会给我们使用<code>dataclasses</code>造成麻烦。</p><p>考虑以下的使用情形：你有一个数据类用于存放用户的信息。现在，它可能存在以下字段：</p><ul><li>姓名</li><li>年龄</li><li>身高</li><li>体重</li></ul><p>你仅想比较用户对象的年龄、身高和体重。你不想比较姓名。这是后端开发者经常会遇到的使用情景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">order=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    name:<span class="hljs-built_in">str</span><br>    age：<span class="hljs-built_in">int</span><br>    height:<span class="hljs-built_in">float</span><br>weight:<span class="hljs-built_in">float</span><br></code></pre></td></tr></table></figure><p>自动生成的比较方法会比较以下的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(self.name，self.agerself.height， self.weight)<br></code></pre></td></tr></table></figure><p>这将会破坏我们的意图。我们不想让姓名<code>（name）</code>用于比较。那么，如何使用<code>dataclasses.field</code>来实现我们的想法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">orde=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>name:<span class="hljs-built_in">str</span>=field(compare=<span class="hljs-literal">False</span>)<br>age:<span class="hljs-built_in">int</span><br>weight:<span class="hljs-built_in">float</span><br>height:<span class="hljs-built_in">float</span><br>&gt;&gt;&gt;user_1=User(<span class="hljs-string">&quot;John Doe&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-number">70</span>,<span class="hljs-number">1.70</span>)<br>&gt;&gt;&gt;user_2=User(<span class="hljs-string">&quot;Adam&quot;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">65</span>,<span class="hljs-number">1.60</span>)<br>&gt;&gt;&gt;user_1&lt;user_2<br>&gt;&gt;&gt;<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>默认情况下，所用的字段都用于比较，因此我们仅仅需要指定哪些字段用于比较，而实现方法是直接把不需要的字段定义为<code>filed（compare=False）</code>。</p><h3 id="3-使用全部字段进行数据表示"><a href="#3-使用全部字段进行数据表示" class="headerlink" title="3.使用全部字段进行数据表示"></a>3.使用全部字段进行数据表示</h3><p>自动生成的<code>__repr__</code>方法使用所有的字段用于表示。当然，这也不是大多数情形下的理想选择，尤其是当你的数据类有大量的字段时。单个对象的表示会变得异常臃肿，对调试来说也不利。</p><p>我们也能够个性化这种行为。考虑一个类似的使用场景，也许最合适的用于表示的属性是姓名（name）。那么对<code>__repr__</code>，我们仅使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass(<span class="hljs-params">order=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>name:<span class="hljs-built_in">str</span>=field(compare=false)<br>age:<span class="hljs-built_in">int</span>= field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>)<br>height:<span class="hljs-built_in">float</span>= field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>)<br>weight:<span class="hljs-built_in">float</span>= field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>)<br>city:<span class="hljs-built_in">str</span>=field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>,compare=<span class="hljs-literal">False</span>)<br>country:<span class="hljs-built_in">str</span>=field(<span class="hljs-built_in">repr</span>=<span class="hljs-literal">False</span>,compare=<span class="hljs-literal">False</span>)<br><br>&gt;&gt;&gt;a=User(<span class="hljs-string">&quot;john Doe&quot;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">70</span>,<span class="hljs-string">&quot;Massachusetts&quot;</span>,<span class="hljs-string">&quot;United States ofAmerica&quot;</span>)<br>&gt;&gt;&gt;b=User(<span class="hljs-string">&quot;Adam&quot;</span>,<span class="hljs-number">24</span>,<span class="hljs-number">1.6</span>,<span class="hljs-number">65</span>,<span class="hljs-string">&quot;San Jose&quot;</span>,<span class="hljs-string">&quot;United Statesof America&quot;</span>)<br><br>&gt;&gt;&gt;a<br>&gt;&gt;&gt;User(name=<span class="hljs-string">&#x27;john Doe&#x27;</span>)<br>&gt;&gt;&gt;b<br>&gt;&gt;&gt;User(name=<span class="hljs-string">&#x27;Adam&#x27;</span>)<br>&gt;&gt;&gt;b&gt;a<br>&gt;&gt;&gt;<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="4-从初始化中省略字段"><a href="#4-从初始化中省略字段" class="headerlink" title="4.从初始化中省略字段"></a>4.从初始化中省略字段</h3><p>目前为止我们看到的所有例子，都有一个共同特点——即我们需要为所有被声明的字段传递值，除了有默认值之外。在那种情形下（指有默认值的情况下），我们可以选择传递值，也可以不传递。</p><p>但是，还有一种情形：我们可能不想在初始化时设定某个字段的值。这也是一种常见的使用场景。也许你在追踪一个对象的状态，并且希望它在初始化时一直被设为<code>False</code>。更一般地，这个值在初始化时不能够被传递。</p><p>那么，我们如何实现上述想法呢？以下是具体内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>email:<span class="hljs-built_in">str</span>= field(<span class="hljs-built_in">repr</span>= <span class="hljs-literal">True</span>)<br>verified:<span class="hljs-built_in">bool</span>=field(<span class="hljs-built_in">repr</span> = <span class="hljs-literal">False</span>,init=<span class="hljs-literal">False</span>,default=<span class="hljs-literal">False</span>)<br><span class="hljs-comment">#Omit verified from representation as well as __init__</span><br><br><br>&gt;&gt;&gt;a = User(<span class="hljs-string">&quot;a@test.com&quot;</span>)<br>&gt;&gt;&gt;User(email=<span class="hljs-string">&#x27;a@test.com&#x27;</span>)<br>&gt;&gt;&gt;a.verified<br>&gt;&gt;&gt;<span class="hljs-literal">False</span><br>        <br>        <br>&gt;&gt;&gt;b= User(<span class="hljs-string">&quot;betest.com&quot;</span>,<span class="hljs-literal">True</span>)<span class="hljs-comment">#Let us try to pass the value of verified</span><br>&gt;&gt;&gt;Traceback(most recent cal1 last):<br>    File<span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>,line1,<span class="hljs-keyword">in</span>&lt;module&gt;<br>TypeError:__init__()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typing库的使用！🍩</title>
    <link href="/2023/12/06/%E7%AE%97%E6%B3%95/python/python%E4%B8%ADtyping%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/06/%E7%AE%97%E6%B3%95/python/python%E4%B8%ADtyping%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="typing库的使用"><a href="#typing库的使用" class="headerlink" title="typing库的使用"></a>typing库的使用</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><ul><li><strong>typing模块的作用：</strong></li></ul><ol><li>类型检查，防止运行时出现参数和返回值类型不符合。</li><li>作为开发文档附加说明，方便使用者调用时传入和返回参数类型。</li><li>该模块加入后并不会影响程序的运行，不会报正式的错误，只有提醒。</li></ol><ul><li><strong>下面说说typing模块常用的方式：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Tuple</span>, <span class="hljs-type">Dict</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a:<span class="hljs-built_in">int</span>, string:<span class="hljs-built_in">str</span>, f:<span class="hljs-built_in">float</span>, b:<span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-type">List</span>, <span class="hljs-type">Tuple</span>, <span class="hljs-type">Dict</span>, <span class="hljs-built_in">bool</span>]:<br>    list1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(a))<br>    tup = (string, string, string)<br>    d = &#123;<span class="hljs-string">&quot;a&quot;</span>:f&#125;<br>    bl = b<br>    <span class="hljs-keyword">return</span> list1, tup, d,bl<br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;hhhh&quot;</span>, <span class="hljs-number">2.3</span>, <span class="hljs-literal">False</span>))<br><span class="hljs-comment"># 结果：([0, 1, 2, 3, 4], (&#x27;hhhh&#x27;, &#x27;hhhh&#x27;, &#x27;hhhh&#x27;), &#123;&#x27;a&#x27;: 2.3&#125;, False)</span><br></code></pre></td></tr></table></figure><ul><li><strong>说明：</strong></li><li>在传入参数时通过“参数名:类型”的形式声明参数的类型；</li><li>返回结果通过”-&gt; 结果类型”的形式声明结果的类型。</li><li>在调用的时候如果参数的类型不正确pycharm会有提醒，但不会影响程序的运行。</li><li>对于如list列表等，还可以规定得更加具体一些，如：“-&gt; List[str]”,规定返回的是列表，并且元素是字符串。</li><li><strong>由于python天生支持多态，迭代器中的元素可能多种，如下：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a:<span class="hljs-built_in">int</span>, string:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>]:<br>    list1 = []<br>    list1.append(a)<br>    list1.append(string)<br>    <span class="hljs-keyword">return</span> list1<br><br><span class="hljs-comment"># 使用or关键字表示多种类型</span><br></code></pre></td></tr></table></figure><ul><li><strong>typing常用的类型：</strong></li><li>int,long,float: 整型,长整形,浮点型;</li><li>bool,str: 布尔型，字符串类型；</li><li>List, Tuple, Dict, Set:列表，元组，字典, 集合;</li><li>Iterable,Iterator:可迭代类型，迭代器类型；</li><li>Generator：生成器类型；</li></ul><h2 id="2-具体案例"><a href="#2-具体案例" class="headerlink" title="2.具体案例"></a>2.具体案例</h2><h3 id="2-1-typing的使用范围"><a href="#2-1-typing的使用范围" class="headerlink" title="2.1 typing的使用范围"></a>2.1 typing的使用范围</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataLoader</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;docstring for FileToProblemText.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, user_config: UserConfig</span>):<br>        self.file_path = user_config.get_dataset_path()<br>        self.file_type = user_config.get_dataset_type()<br>        self.chunk_size = user_config.get_dataset_size()<br></code></pre></td></tr></table></figure><p>这段代码中的<code>user_config: UserConfig</code>不需要导入typing库，在Python 3.5及更高版本中，类型提示已经成为一种标准的语言特性。同时，对于返回值的类型提示<code>—&gt;</code>也不需要导入。</p><p>只有在泛型提示，即准确知道列表或字典中的数据类型时，才需要用到Typing库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SolvingEngine</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.logger = logging.getLogger(self.__class__.__module__)<br>        self.graph: GraphOfStates = GOS_generator()<br>        self.shared_state_data: SharedStateData = SharedStateData()<br>        self.run_states: <span class="hljs-type">List</span>[State] = []<br>        self.result: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] = &#123;&#125;<br>        self.executed: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>对于具体的类型，使用<code>List</code>或者<code>Dict</code>来表示。</p><h3 id="2-2-Union的使用"><a href="#2-2-Union的使用" class="headerlink" title="2.2 Union的使用"></a>2.2 Union的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Type</span>, <span class="hljs-type">Union</span><br><br><span class="hljs-comment"># 这个类型提示表示一个类型，该类型可以是以下类之一的实例：</span><br><span class="hljs-comment"># DatasetMultiEncDec, DatasetEPT, DatasetHMS, DatasetGPT2,</span><br><span class="hljs-comment"># PretrainDataset, SingleEquationDataset, MultiEquationDataset, AbstractDataset</span><br>DatasetType = <span class="hljs-type">Type</span>[<span class="hljs-type">Union</span>[<br>    DatasetMultiEncDec, DatasetEPT, DatasetHMS, DatasetGPT2,<br>    PretrainDataset, SingleEquationDataset, MultiEquationDataset, AbstractDataset<br>]]<br><br></code></pre></td></tr></table></figure><p>这个类型提示使用了 <code>Union</code> 类型，表示被注解的对象可以是其中列举的多个类型中的任意一个。同时，使用 <code>Type</code> 类型表示这是一个类对象的类型提示。因此，<code>DatasetType</code> 表示一个类，该类是上述列举的多个类之一。</p>]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Live2d基础知识!🍹</title>
    <link href="/2023/12/06/live2d/%E6%8A%80%E5%B7%A7/live2d%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/06/live2d/%E6%8A%80%E5%B7%A7/live2d%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Live2d ʕʽɞʼʔ</category>
      
      <category>Live2d制作技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Live2d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视图和物体控制!🥕</title>
    <link href="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="视图和物体控制"><a href="#视图和物体控制" class="headerlink" title="视图和物体控制"></a>视图和物体控制</h1><h2 id="1-控制视图和视角"><a href="#1-控制视图和视角" class="headerlink" title="1.控制视图和视角"></a>1.控制视图和视角</h2><blockquote><p>观察3D空间</p></blockquote><p><code>鼠标中键</code>或者点击视图窗口右上角的<code>小球图标</code><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png"></p><blockquote><p>平移3D空间</p></blockquote><p><code>shift+鼠标中键</code>或者点击视图窗口右上角的<code>小手图标</code><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png"></p><blockquote><p>缩放3D空间</p></blockquote><p><code>滚动鼠标中键</code>或者点击视图窗口右上角的<code>放大镜图标</code><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png"></p><blockquote><p>摄像机视角和正交 &#x2F; 透视视角切换</p></blockquote><p><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.png"></p><h2 id="2-控制物体模型"><a href="#2-控制物体模型" class="headerlink" title="2.控制物体模型"></a>2.控制物体模型</h2><blockquote><p>新建物体</p></blockquote><p><code>shift + A</code></p><blockquote><p>正常的移动 &#x2F; 旋转 &#x2F; 缩放工具</p></blockquote><p><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.png"></p><blockquote><p>移动</p></blockquote><p>移动快捷键：<code>G</code></p><p>移动且具有所有固定轴：<code>G + 鼠标中键</code>，选择轴后松开鼠标中键即会保留选择轴。</p><p>固定轴移动：<code>G + X/Y/Z</code></p><p>撤销移动（恢复到原点）：<code>alt + G</code></p><p>吸附移动：<code>G + ctrl</code></p><blockquote><p>旋转</p></blockquote><p>旋转快捷键：<code>R</code></p><p>旋转且具有所有固定轴：<code>R + 鼠标中键</code>，选择轴后松开鼠标中键即会保留选择轴。</p><p>固定轴旋转：<code>R + X/Y/Z</code></p><p>撤销旋转：<code>alt + R</code></p><blockquote><p>缩放</p></blockquote><p>缩放快捷键：<code>S</code></p><p>缩放且具有所有固定轴：<code>S + 鼠标中键</code>，选择轴后松开鼠标中键即会保留选择轴。</p><p>固定轴缩放：<code>S + X/Y/Z</code></p><p>撤销缩放：<code>alt + S</code></p><blockquote><p>删除</p></blockquote><p>删除快捷键：<code>Del</code> 或者  <code>X</code></p><blockquote><p>隐藏 &#x2F; 显示</p></blockquote><p>隐藏选中物体快捷键：<code>H</code></p><p>隐藏未选中物体快捷键：<code>shift + H</code></p><p>显示快捷键：<code>alt + H</code></p><p>或者右上角<code>眼睛图标</code></p><p><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.png"></p><blockquote><p>复制</p></blockquote><p>移动并复制快捷键：<code>shift + D</code></p><p><strong>注意：</strong>ctrl + Z撤回的话只是撤回移动部分，物体仍然被复制。</p><blockquote><p>选择</p></blockquote><p>长按左上角箭头，出现四个选项</p><p><img src="/2023/12/06/%E5%BB%BA%E6%A8%A1/blender/%E6%8A%80%E5%B7%A7/blender%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.png"></p><p>调整：单选并移动物体。</p><p>框选：选框的方式进行多选。</p><p>刷选：移动鼠标进行多选。</p><p>套索：套索的方式进行多选。</p><p>切换选择工具：<code>W</code></p><h2 id="3-切换视图"><a href="#3-切换视图" class="headerlink" title="3.切换视图"></a>3.切换视图</h2><blockquote><p>方法一</p></blockquote><p>直接点击右上角小圆球的红蓝绿三个键</p><blockquote><p>方法二</p></blockquote><p>小键盘的数字键：</p><p>0 摄像机视角</p><p>1 &#x2F; 3 &#x2F; 7 &#x2F; 9 调整视图</p><p>2 &#x2F; 4 &#x2F; 6 &#x2F; 8 偏移视角，每按一次转15°</p><p>5 调整正交和透视</p><p>点击<code>.</code>，点击物体可将对象放大至视图中心</p><blockquote><p>方法三</p></blockquote><p>长按<code>~</code>键，选择视图</p><blockquote><p>方法四</p></blockquote><p><code>alt + 鼠标中键</code>改变视图</p>]]></content>
    
    
    <categories>
      
      <category>建模 ʕథ౪థʔ</category>
      
      <category>Blender</category>
      
      <category>Blender建模技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maya建模基础知识！🍒</title>
    <link href="/2023/12/06/%E5%BB%BA%E6%A8%A1/maya/%E6%8A%80%E5%B7%A7/maya%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/06/%E5%BB%BA%E6%A8%A1/maya/%E6%8A%80%E5%B7%A7/maya%E5%BB%BA%E6%A8%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>建模 ʕథ౪థʔ</category>
      
      <category>Maya</category>
      
      <category>Maya建模技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Maya</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VFX魔法球特效！🎈</title>
    <link href="/2023/11/19/%E6%B8%B8%E6%88%8F/VFX/%E8%AE%BE%E8%AE%A1/Unity-VFX-MagicBall/"/>
    <url>/2023/11/19/%E6%B8%B8%E6%88%8F/VFX/%E8%AE%BE%E8%AE%A1/Unity-VFX-MagicBall/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/11/19/%E6%B8%B8%E6%88%8F/VFX/%E8%AE%BE%E8%AE%A1/Unity-VFX-MagicBall/1.gif"></p>]]></content>
    
    
    <categories>
      
      <category>Unity ᶘ ᵒᴥᵒᶅ</category>
      
      <category>VFX</category>
      
      <category>VFX设计案例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai翻书特效！🌞</title>
    <link href="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/"/>
    <url>/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Ai翻书特效"><a href="#Ai翻书特效" class="headerlink" title="Ai翻书特效"></a>Ai翻书特效</h1><p>效果如下图所示：</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/13.png"></p><p>实现该效果需要用到三个步骤：</p><p>1.文字工具</p><p>2.混合工具</p><p>3.变形工具</p><p>4.阴影工具</p><h2 id="1-文字工具创造轮廓"><a href="#1-文字工具创造轮廓" class="headerlink" title="1.文字工具创造轮廓"></a>1.文字工具创造轮廓</h2><p>首先用文字工具创造希望产生特效的文字</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/1.png"></p><p>然后对整体进行扩展</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/2.png"></p><p>扩展后文字将按照形状产生相应的路径，并形成一个编组</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/3.png"></p><p>最后将其解组，形成一个个单独的文字路径</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/4.png"></p><h2 id="2-混合工具产生基本的效果"><a href="#2-混合工具产生基本的效果" class="headerlink" title="2.混合工具产生基本的效果"></a>2.混合工具产生基本的效果</h2><p>首先复制一个文字，并改变其颜色</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/5.png"></p><p>然后使用混合工具指定步数产生混合后的效果</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/6.png"></p><h2 id="3-变形工具调整角度"><a href="#3-变形工具调整角度" class="headerlink" title="3.变形工具调整角度"></a>3.变形工具调整角度</h2><p>使用变形工具调整角度，使其更加立体</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/7.png"></p><p>调整后的效果如下图所示</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/8.png"></p><h2 id="4-添加阴影效果"><a href="#4-添加阴影效果" class="headerlink" title="4.添加阴影效果"></a>4.添加阴影效果</h2><p>首先将混合后的文字进行扩展并解组，扩展会让其每一层都具有路径</p><p>解组后每一层都可以自由移动</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/10.png"></p><p>然后在效果中添加阴影</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/9.png"></p><p>添加阴影后再对所有图层编组</p><p><strong>注意：</strong>编组快捷键为Ctrl+G</p><p>最后为第一层添加渐变效果，产生光泽感</p><p><img src="/2023/11/18/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E7%BF%BB%E4%B9%A6%E7%89%B9%E6%95%88/12.png"></p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>Ai</category>
      
      <category>Ai设计案例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai混合工具的使用！🌸</title>
    <link href="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ai混合工具的使用"><a href="#Ai混合工具的使用" class="headerlink" title="Ai混合工具的使用"></a>Ai混合工具的使用</h1><p>Ai混合主要由混合选项中三个不同的参数控制</p><p>进入方式为：<strong>对象—-&gt;混合</strong></p><p>1.平滑的颜色</p><p>2.指定的步数</p><p>3.指定的距离</p><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/1.png"></p><p>初始图如下所示：</p><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/2.png"></p><h2 id="1-平滑的颜色"><a href="#1-平滑的颜色" class="headerlink" title="1.平滑的颜色"></a>1.平滑的颜色</h2><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/3.png"></p><h2 id="2-指定的步数"><a href="#2-指定的步数" class="headerlink" title="2.指定的步数"></a>2.指定的步数</h2><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/4.png"></p><h2 id="3-指定的距离"><a href="#3-指定的距离" class="headerlink" title="3.指定的距离"></a>3.指定的距离</h2><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/5.png"></p><h2 id="4-混合的原因"><a href="#4-混合的原因" class="headerlink" title="4.混合的原因"></a>4.混合的原因</h2><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/6.png"><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/7.png"></p><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/8.png"></p><p><img src="/2023/11/18/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E6%B7%B7%E5%90%88%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/9.png"></p><p>如上图所示我们可以观察到，改变图层的顺序会改变混合的方式</p><p>哪一个图层在上面，哪一个图层在混合图层中也会在最上方</p><p>而另一个图层在最下方</p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>Ai</category>
      
      <category>Ai矢量图设计技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai作图的操作顺序！🌸</title>
    <link href="/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Ai作图的操作顺序"><a href="#Ai作图的操作顺序" class="headerlink" title="Ai作图的操作顺序"></a>Ai作图的操作顺序</h1><p>如下图所示是一张用Ai画的矢量人脸图：</p><p><img src="/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/1.png"></p><p>因为Ai填色需要对闭合的钢笔线圈进行操作，所以面对上图中带有勾线的图形，需要分层进行操作。</p><h2 id="1-画出底色"><a href="#1-画出底色" class="headerlink" title="1.画出底色"></a>1.画出底色</h2><p>先用钢笔画出图像最底层的图形，如下图所示：</p><p><img src="/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/2.png"></p><p><strong>注意：</strong>画底色时，选择没有描边的钢笔</p><h2 id="2-逐层上色"><a href="#2-逐层上色" class="headerlink" title="2.逐层上色"></a>2.逐层上色</h2><p>如下图所示画出图形分层的色彩：</p><p><img src="/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/3.png"></p><p>每一层画出闭合的钢笔线圈</p><h2 id="3-画出勾线"><a href="#3-画出勾线" class="headerlink" title="3.画出勾线"></a>3.画出勾线</h2><p>在将底色画完之后，选择有描边的钢笔进行描边，最终呈现完整的图形</p><p><img src="/2023/11/16/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E5%9B%BE%E5%83%8F%E7%9A%84%E6%93%8D%E4%BD%9C/4.png"></p><p>线框图如上所示</p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>Ai</category>
      
      <category>Ai矢量图设计技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十章 · 乌鹊绕南枝❤️‍🔥</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="乌鹊绕南枝"><a href="#乌鹊绕南枝" class="headerlink" title="乌鹊绕南枝"></a>乌鹊绕南枝</h1><p>  　　“咚！——————”</p><p>　　寺庙的钟声不知何时敲响，庄严而又带着悲悯。</p><p>　　“闻钟声，菩提生。”苏景回头瞄了一眼寺庙斑驳红墙上的蛛丝，有些好奇是谁在这座无人问津的寺庙里醒钟。</p><p>　　他的神识扫过来来往往的人群，将每个人脸上的表情和神色都瞧了个明白。</p><p>　　有身着布衣的妇人背着衣不遮体的婴儿愁容满面；也有满面书生气的文人秀才站在路旁发呆，神情木讷；而更多的是背着大刀长枪，或冷漠，或奸邪，或狠决地徘徊游荡在大街上的人。</p><p>　　菩萨好像都无动于衷地放弃了他们。</p><p>　　如今各地都不太平，边境处尤甚，这里的人们都抱着活一日是一日的念头。为何这里的寺庙门可罗雀，衰败地没有任何香火，苏景转念间便有了答案。</p><p>　　在活着都是奢望的地方，烧香拜佛就成了稀罕事儿。能救他们的不是日夜礼佛，也不是磕破了脑袋求菩萨保佑，而是握在他们手中的真刀实枪。</p><p>　　苏景还沉浸在思绪之中，就被不远处人群中传来的骚乱打断。他悄悄远转内力，正想收回神识，却发现骚乱处有一群蒙着面的武士大步流星地朝他们这边闯来。</p><p>　　苏景偏头望向苏野，正巧苏野也在回望着他。“他们好像是冲我们来的。”苏景指了指地上的草药，有些意料之中地摊手说道。</p><p>　　“嗯。”苏野沉声回应，“该来的总会来的。”说罢，他扭头看向了那些迎面而来的武士，往前半步将苏景护在身后，同时悄然运转血脉之力，劲风在周身鼓动，衣袂猎猎。</p><p>　　“看这架势，倒不像是小门小派的人。可为何要蒙着面，难道是…”苏景看向那群武士，又扫了一圈十步开外朝这边好奇张望的人群。虽然这些武士都在极力表现出莽撞，但他们相互之间的距离却时刻维持着一种微妙的平衡。</p><p>　　短短数息后，那十数名武士就将苏景和苏野呈环形包围起来。苏野低声对苏景说：“一会儿我来拦住他们，你带着药材先走。”说罢，不等苏景回答，玄青色狼影便以磅礴之势从苏野身后腾起，可怖的能量狂潮毫无保留地从苏野体内席卷而出。</p><p>　　为首的武士死死盯着苏野身后的狼影，金色面具背后的双眸之中似乎有森然的火焰在曳动。他缓缓握住腰间的刀柄，然后朝苏野开口说道：“交出药材，走；不交，死。”</p><p>　　话音刚落，一道裹挟着凛冽战意的拳风便朝为首的武士奔袭而去，随后传来苏野冷漠到极致的声音：“就凭你们，也配？”</p><p>　　为首的那名武士在感受到拳风之中蕴含的浩瀚能量之后，眸中显露了诧异之色。但他也没有表现出丝毫的慌乱，而是紧闭双眼，同时右脚向外迈出一步，脚下有朱红流光涌动。</p><p>　　在拳风离他仅有毫厘之差时，为首的武士陡然睁眼。朱红色的火焰宛如实质一般的在他双眸前肆意地燃烧，而苏野的拳风好像被禁锢住似的停滞不前，随后便同那沸腾后的水汽儿，在吞吐间便消融在空气之中。</p><p>　　周遭的声音突然安静了下来，只听得见那熊熊的火焰发出的“滋滋”声。突然，为首的那名武士向后退了一步，然后抬手朝前一挥，顿时所有武士都拔出了腰间的佩刀，拔刀的锵鸣声惊地树上的鸟儿都慌了翅膀逃走。</p><p>　　每一把刀的刀尖都直直地指向了苏野。</p><p>　　苏野却仿佛没看见那些刀尖上流转的血腥气，而是偏头望向苏景。在和苏景眼神交汇的一刹那，苏野自己都没发现他眉峰陡然地舒展。</p><p>　　尽管这个世界破烂不堪，但他回头仍能看到希望，这便够了。</p><p>　　“我数到三，你就往后跑。”苏野轻声对苏景说。不待苏景回答，苏野又补充道：“听话。”</p><p>　　苏景把没说的话咽进肚子里，有些无奈的摇摇头，心想着，苏野还是把他当小孩子哄。</p><p>　　“一。”苏野回头，那些武士已经提刀向这边冲来。他毫无保留的将体内的所有能量释放，身后的狼影顷刻间又暴涨了三分，巨大的玄青色狼影将身体弓起，寻找一击制敌的机会。</p><p>　　“左二进一，右五平三。”</p><p>　　“二。”</p><p>　　“三…”话音未落，正当苏野准备调动血脉下隐藏的凶煞之力时，却听到了苏景地大喊声。</p><p>　　“等一下！”</p><p>　　武士走进了身后的庙宇，苏景自顾自地喃喃道：“果然是他。”</p><p>　　苏景问：“二当家为何有心情在这醒钟？”</p><p>　　“有些装睡的人啊，也该醒醒了。”</p><p>　　回去的路上，苏景给一个生病的小孩药材。</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　　</p><p>　二当家逛了逛这里的寺庙，随意的在菩萨面前做着不正经的事情。</p><p>　　</p><p>　“我们啊，都是站在菩萨背后的人，菩萨哪瞧得见咱们？”</p><p>　　</p><p>　　</p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九章 · 鸣蛩惊梧桐🤎</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="鸣蛩惊梧桐"><a href="#鸣蛩惊梧桐" class="headerlink" title="鸣蛩惊梧桐"></a>鸣蛩惊梧桐</h1><p> 　　栋宇相望，桑梓接连。怀桑殿中的桑树像是一夜之间耗尽了生气，连带着怀梓殿中的梓树也衰败了大半。它们像是流干了眼泪的孩童，眼底只剩下不仁的麻木。</p><p>　　没过几日，一则震惊整个白谷域，乃至整个大乌都有所耳闻的消息传了出来，白谷域域主的小儿子，因与长兄生嫌已久，遂在金鸾祭当晚手刃了兄长，域主大人一怒之下将其击杀，然后急火攻心昏倒在了殿中。</p><p>　　又过了好些时日，当苏景在饭桌上听到苏野提起此事时，不禁感慨道：“大乌的人可真够狠的。”苏野挑了挑眉，状若无意的回了一句：“假作真时真亦假，无为有处有还无。”然后两人对视一眼，继续吃饭了。</p><p>　　苏野几日前就跟苏景商量着去山谷的更深处寻些珍贵的草药，然后拿到城中去卖。最近战事颇多，大大小小的流寇扰的人心惶惶，需要药材的人应该也不少。</p><p>　　“那日王觋医离开前我曾问过，这片山谷里有一种极为罕见的玉麟草，可治百病，他曾在年少的时候遇过一株，之后便无迹可寻了。”苏野对苏景说道。</p><p>　　苏景坐在门口的青石上，望着不远处在枝桠间载飞载下的衔欢燕，撑着脑袋说：“这好办，我和你一块去寻。”苏野摇了摇头，皱眉道：“太危险了，我一个人去便可。”</p><p>　　苏景撇了撇嘴，仰头看着苏野，状似不满的说道：“苏野，你忘了我的看家本领是什么了吗？”苏野怔然，随后想起什么似的恍然大悟，略微思索了片刻后说：“那我们明早出发。”</p><p>　　苏景拍了拍自己的胸脯，自信非常的说道：“包在我身上！什么玉麟草，万年参我都能给你挖出来！”苏野微微点头，不置可否。</p><p>　　第二日天刚蒙蒙亮，一抹鱼肚白好似从山涧清淙中缓缓流淌而出。苏野在闭目凝神之际就听到耳边传来一阵窸窣，紧接着就听到苏景扯着嗓子喊：“起！床！…唔！”</p><p>　　苏野一手捂着苏景的嘴巴，一手揉了揉自己的耳朵，然后从被褥上仰身而起。苏景从狼爪下躲开，颇有些迫不及待地拉着苏野往外走，边走边说道：“早上我已经在附近探查了一番，跟我来！”</p><p>　　苏野就这么跟着苏景往山谷的深处走，苏景走在前面，眼眸虚张，在他身前还有星星点点的墨绿色荧光跃动着汇成一条蜿蜒的蛇线，似乎在指引着他们前行的方向。</p><p>　　苏野在距苏景身后一步之外的地方不紧不慢的跟随着，狼眸微眯，瞳孔里血色纹路若隐若现。当他们来到毫无人迹的地方后，每往山谷深处行进一里，苏野的神经便更紧绷一分。</p><p>　　走着走着，阳光好像变的越来越稀薄，两个人的步子放缓，苏景身前的绿色荧光突然突兀的四散开来，如惊弓之鸟般的消失在两人眼前。</p><p>　　苏景蓦地睁开眼，神识向周围释放而出，鎏色的金光将这方空间都照亮了几分。苏景微微皱眉，在稀薄的阳光下似乎有一层极淡的雾在游走着。</p><p>　　一缕似有若无的空气掠过苏景的鼻尖，霎时间滔天的火光在苏景的脑海里涌现，吞天坼地的轰鸣声让苏景的神识都变的摇摇欲坠。苏景赶紧运转神识，将扩散于外的神识聚拢在眉心，嘴里大喝：“苏野！屏气凝神！这里有妄气！”</p><p>　　妄气，言其虚妄之相随念而起也。它能唤起人心中最可怕的念头，神识孱弱者一个不慎便会在无尽的虚妄中沉沦。</p><p>　　苏景虽说没修炼心法，但神识能量极为庞大，在吸入妄气的刹那间便靠着磅礴的神识能量抑住了内心的妄念。可妄念在脑海里出现的那片刻，依旧让他的心神动荡不已。</p><p>　　苏景深呼了一口气，陡然听见了身后一声l悲戚的狼嚎。“不好！”苏景急忙转头，发现苏野双手抱着脑袋跪坐在地上，脖颈和额头的青筋暴起，猛烈的抽动着。</p><p>　　苏野死死咬着牙，面部的肌肉因为太过用力而不住地颤抖，紧锁的眉峰被血光和戾气笼罩在内，身后一张巨大的玄青色狼影也低伏着头颅，狼尾不安又狂躁的不断晃动。</p><p>　　苏野感觉血液里的那股能量要把他撕碎了，他好像置身在滚烫的沸水中，体内升腾的热浪将他一寸一寸的吞噬。脑子里是无穷无尽的尸山血海，无数凄厉的哀鸣声仿佛在撕扯着他的神经，势必要让他一同坠入血海。</p><p>　　苏景看到他这副模样，急忙双手结印，安神诀和神识如洪流般的朝苏野涌去，除了维持自己不被妄气侵袭的那一部分能量外，其余的能量尽数传向了苏野。</p><p>　　苏景的神识刚接触苏野的那一刻，苏野浑身暴动的能量有片刻的收敛，然而没过多久，苏景就发现无论是他的神识还是安神诀都没法减弱苏野的痛苦。</p><p>　　冷汗不断的自苏野额头滑落，背后也早已被汗水浸湿。他像是搁浅在岸的鱼，狼狈又无措的喘息着。苏景又尝试给苏野灌输自己的能量，仍是不起半分作用。</p><p>　　苏景毫不犹豫的右手化刃，正欲往自己左手动脉划下的时候，被一只颤抖却有力的手握住了手腕。</p><p>　　苏野微微侧头，眼神里是隐晦的坚持，他喉间微动，从牙缝间挤出几个字：“不…要…”，然后轻轻晃了晃苏景化刃的胳膊。</p><p>　　苏景反手就抓住了苏野的手掌，有些哽咽的细声说道：“别怕，我马上就带你回家。”说罢，便欲起身去背苏野。苏野摇了摇头，无力地说：“别让…奶奶知道…，我们还要…还要采药…”</p><p>　　他望着苏景，扯了扯干涩的嘴角，道：“你…能不能…转过去，陪我说说话…”语气里有极力遏制的痛苦。苏景盯了他片刻，然后在苏野带着哀求的目光中缓缓转身。</p><p>　　他双手死死攒着衣角，努力强迫自己沉浸在回忆里。</p><p>　　“小的时候，我不小心打碎了母亲留下的一对鸳鸯玉，那是父亲第一次，也是最后一次冲我发火…”</p><p>　　“在学堂上学，我交了很多好朋友，偶尔喜欢发呆的小和尚，总是想家的虎妞，还有嘴硬心软的…”<br>　　……</p><p>　　苏景不知道自己说了多久，他只能感觉到身后之人不断传来压抑的闷哼和身体摩擦地面的声音。</p><p>　　慢慢地，阳光抽丝剥茧般的褪去，连带着妄气也消失在阴影里。等空气中的妄气尽数退散后，苏景悬着的心才松了绳。他试探性地喊了一声：“苏野？”没有听到回答，他猛地回头，却落进了一双深邃的眸子里。</p><p>　　他从那眸子里看到了寥廓的山，凛冽的风，还有…愣神的自己。眸子里的山风就那么把他包裹着，裹得他的胸膛不受控制的起伏起来。</p><p>　　苏景的呼吸有些急促，刚欲开口就听到苏野弱弱喊了声：“冷。”他赶紧坐的离苏野近些，就见到苏野伸手紧紧环住了他的手臂，嘴里嘟囔着：“太阳是不是被你赶跑了？”</p><p>　　苏景不免有些好笑，哄小孩子一样的说：“太阳啊也要休息了，再等一会儿，等我们小狼睡着了，太阳就出来了。”苏野闭上眼，过了一会儿又皱着眉头说：“睡不着。”</p><p>　　“睡不着就数…”苏景刚想说数星星，却发现今晚的天空黑的没有任何光亮。耳边却传来苏野的声音：“一，二，三…”数着数着，苏野的声音慢慢变轻，直到“七十一。”苏野把这个数字念的格外清晰，然后便安静了下来。</p><p>　　第二日一早，苏野被阳光晒得眼皮发烫。他惺忪地睁开眼，就见到苏景站在光亮里，朝他伸出手，面带笑意的对他说：“回家吧。”</p><p>　　苏野愣在原地，阳光从头顶将苏景笼罩起来，然后慢慢的，一点点的，驱走了他身后的黑暗。</p><p>　　尘芥镇。鹿行扬尘，余舟一芥。</p><p>　　尘芥镇是大赢和大乾绵延万里的边界线中，较为出名的一座大镇。这里混杂着大赢和大乾各方势力的眼线，也是无数走途无路之人的避难所。</p><p>　　由于大赢和大乾经年累月的摩擦，逃离在此的流民不断壮大，逐渐发展成一些大大小小的集团势力，其中最出名的就是“雔帮”。</p><p>　　雔帮有两位帮主，大帮主是赢国的边防士兵，据说在一次和大乾的战争中，因为不战而退被将军全境捉拿，方才逃到此地。</p><p>　　二帮主的身份鲜有人知道，江湖谣传，大帮主在和其他帮派的斗争中，险些身亡，是二帮主在关键时刻挺身而出，救大帮主于危难。</p><p>　　苏景和苏野将这尘芥镇的大致情况了解后，便找了块靠近寺庙的干净地方，将药材分门别类的铺在地上。</p><p>　　上次苏野被妄气侵袭后，苏景便在周围发现了一小片玉麟草，约莫十数株。后来两人又在整片山群探查了一番，将好些珍稀罕见的药材都搜刮了个干净。</p><p>　　苏景找了个有树荫的地方靠着，来来往往的人群中有不少人的视线都会往这个方向打量。当他们发现地上的药材时，许多人眼睛里都冒着贪婪的光。</p><p>　　但是没多久他们就发现，站在药材堆旁的还有一位身材挺拔，目含血光的少年。少年背后玄青色狼影宛如实质，狼眸扫过每一位过路人时，都会散发狠厉的威压。<br>　　<br>　　今日的天气有些闷热，蝉鸣的流响从梧桐树梢间淌出，苏景听着，有些好奇地说：“今日这蝉声倒是比往日山间的更为清亮。”</p><p>　　苏野抬眼朝树上望去，说：“梧桐树高，而且枝叶繁疏，蝉居高处而鸣，这声音自然传的远些。”</p><p>　　不远处的一座楼阁上，一道清拔的身影坐在墨绿屏风旁，面前是红木茶台。他揭开台上的茶盏，热气袅袅升起。他对着杯沿轻轻吹了口气，就听到苏野的话音传入耳侧。那人手上的动作顿了顿，然后嗤笑了一声。</p><p>　　“居高声自远啊。”</p><p>　　他浅抿了一口杯中的茶水，然后随手朝梧桐树甩去一道绿色的劲风，蝉声顿时戛然而止。</p><p>　　“聒噪。”  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章 · 花灯掩晦影🤍</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="花灯掩晦影"><a href="#花灯掩晦影" class="headerlink" title="花灯掩晦影"></a>花灯掩晦影</h1><p>　　“想什么呢这么入神？”白橖还沉浸在那年的淅淅沥沥中，就听到前方一道带着关心的声音传来。“没什么。”白橖敛了敛嘴角，语气淡淡的地对师兄说道。</p><p>　　他放慢了脚步，无声地和人群脱离了些，然后侧头望向山外连绵呼啸地大雪。凚玉山就这么经年累月地被这片银装素裹覆盖着，像是沉睡在地底的墓棺，庄严又永无天日。</p><p>　　几瓣雪花带着醉意似的落在了白橖的水云袍上，像是那日抵在肩头的呵呢。白橖心神微动，目光在眼前的白茫茫上驻了许久，好一会儿方才挪动步子，往人群的方向走去。</p><p>　　而刚刚在白橖肩头小憩的那几瓣雪花们，在化成水汽儿前似乎听到了那人的低语。</p><p>　　“离恨胜似冬雪，更行更远不歇。”</p><p>　　苏景，你还好吗。</p><p>　　苏景在睡梦中不自觉地翻了身，盖在脸上的话本子顺着脸颊向下滑落，在快要砸到地面时被一只宽大的手稳稳地接住。苏野把话本子放到桌面上，又给苏景拢了拢被子，然后将床头的油灯吹灭了。</p><p>　　他把地上的被褥往苏景的方向挪了挪，看着熟睡中的人儿不安分地把被子踢来踢去，苏野又无奈又好笑地把他露在外面的肚子遮上，然后双手搁在脑后躺下了。</p><p>　　挨着苏景，苏野能闻到他身上浅浅地酒香。苏野觉着，这味道里面有冬日晨阳般的暖意，让他能看到寥廓的天空，孤旋的雄鹰，跃蹄的野马，也能让他每晚燥动难捱的心绪逐渐平复。</p><p>　　苏野想起来他们第一次来到奶奶这的场景。这里只有一间空着的屋子，屋里也只有一张单人的小床。苏景走进来的时候就对他说：“你睡床，我睡地上。我在外面睡习惯了，睡床还不太舒服。”</p><p>　　说罢，正想将多余的被褥往地上铺的时候，就被苏野扔到了床上。“？？？”苏景瞪着大眼睛看向若无其事收拾被褥的苏野，脑袋里盘算着他俩要是打一架谁的胜算更大。</p><p>　　没过一会儿苏景就认命地躺在了床上，嘴角却悄悄翘起了弧度。两个人就这么在这里住下了，一住便是三年。</p><p>　　苏野朝苏景的方向翻了个身，狼眸牢牢地注视着苏景，似乎要将他看进骨子里。耳畔边那道带着哭腔的声音不断重复着，一下一下触碰着苏野心里的那片柔软。</p><p>　　他摩挲着手上的戒指，心里却突兀地响起一道声音。</p><p>　　谁也别想抢走苏景。</p><p>　　长夜漫漫，星辰流转。月挂西山，宿鸟出林。</p><p>　　等苏景再次睁开眼睛的时候，房间里面除了他空无一人。巳时的阳光如山间清泉似的倾泻进屋子里，苏景有些迷糊地揉了揉眼睛，目光从眼缝间望见了桌上一只用竹子做的小奶猫。</p><p>　　“狼族都这么喜欢猫的吗？他们是有什么姻亲关系？”苏景有些费解的打了个哈欠，然后打量了一圈屋子里各式各样用竹子做的小猫们，每一个都栩栩如生。不得不说，苏野竹刻的手艺是越来越娴熟了。</p><p>　　苏景慢悠悠的晃荡到房门口，推开门就看到奶奶和苏野坐在桌前吃饭。门打开的前一刻苏野还在低头喝着粥，推开门的一刹那苏野就把目光锁在了苏景身上。</p><p>　　苏景和苏野对视一眼，然后有些担心的问奶奶：“奶奶，您的腰好些了么？”奶奶听到苏景的声音就乐的合不拢嘴，她朝苏景招招手，示意他坐下来吃饭，然后顺了顺苏景翘起来的头发，眼含笑意地慈声说道：“好多了。来，赶紧吃饭。”</p><p>　　话音刚落，苏野就递过来一碗刚盛的热粥。苏景冲着粥呼呼吹了几口气，然后三下五除二的就把粥喝的见了底。他把碗放下，看到苏野已经在等他了，于是对奶奶说：“奶奶，我们先去山下修炼了，晚上再给您抓条大鱼回来！”</p><p>　　奶奶微笑着点头应好，苏景就跟着苏野出门了。夏日温煦，无风无云，空气中带着新长出来的青草味儿，阳光混着水汽儿在山林间漾出一层一层细微的光圈。</p><p>　　苏景刚走到山林的一处拐角，神识就不自觉地泛起鎏光。他惬意地张开双臂，深吸了一口气，将自己包裹进阳光的怀抱，包裹进自然的摇篮。两个人顺着山路来到了一块空旷的平地，这是他们平时修炼的地方。</p><p>　　苏景有些迫不及待地盘腿坐在地上，轻轻闭上双眼，任凭神识向外扩散，跃动着的神识能量和空气中的自然因子悄然碰撞着，不断产生光芒流转的能量涟漪。</p><p>　　苏野看着苏景扩散的越来越远的神识，一丈，五丈，十丈…苏野凝眸，苏景的神识领域有接近十二丈的范围！放眼整个大赢，在十七岁就能到达这个领域范围的人，一般都是出自各大世家的嫡系子弟。</p><p>　　大赢的修炼体系分为心法和身法。心法修的是神识，身法是以身化刃。所谓神，精气不灭者何，多闻见而识乎至道者，至识也，故曰“神识”。如何判断一个人的神识是否强大，最直观的就是领域范围。</p><p>　　范围越大，说明修炼之人的神识能量越浩瀚，越能够支撑的起神识领域中的心法效果。可是，苏野眉峰微蹙，心中思索着，苏景的神识领域虽然很辽阔，但似乎并没有大赢任何一方派系心法的影子。</p><p>　　而且苏景的神识虽有抚人心神，平心静气的能力，却极易和领域内的生灵共情，如若控制不得当，就会遭到反噬。这倒是和大乌圣灵教的教术有异曲同工之效。</p><p>　　苏野心中这般想着，突然察觉到自己血脉中那股躁动不安的能量又开始隐隐肆虐。他阖眸运转内力，将血脉中那如附骨之蛆般的能量压制住。只要和苏景在一起，他压制那股能量的效率就要快上许多。</p><p>　　过了一会儿，苏野睁开眼，缓缓吐出一口浊气。他看向苏景，发现他仍沉浸在神识领域的能量潮汐中。苏野向四周环视一圈，狼眸中有暗红色血光闪烁，像是一头孤狼在审视自己的领地。</p><p>　　最终，他缓缓仰头，死死盯着今日刺眼的有些过头的太阳。他根本不在乎苏景的神识是否强大，有他在，就没人敢欺负他。</p><p>　　他只在乎，苏景是否羁在他的领地。</p><p>　　大乌•金阳域。<br>　　<br>　　每年的七月初九，是圣灵教最重要的日子，因为在这一日，教内会举行盛大的圣鸾祭。届时，太阳的无上荣光会降临在每一位圣教徒的身上。</p><p>　　大乌没有皇族，而是以两大教派为首，统治着这方地域。两大教派其一便是这圣灵教。圣灵教视太阳为信仰，据圣灵教教宗记载：“我教始立也，凤鸟适至，故纪於鸟，以治厉正。”</p><p>　　金阳域的最中心处，有一座富丽堂皇的殿宇，名金鸾殿。殿宇内外，梧桐耸立，殿宇上方，金凤盘栖。</p><p>　　殿内有数道人影，为首之人朝人群之中看了看，待所有人到齐之后，方才对着大殿上方拱手说道：“冕下，圣鸾祭的诸多事宜已经准备就绪，待到午时，便可降下圣谕了。”</p><p>　　大殿内最高处，一道慵懒的声音传来：“神巫教那边可有异常？”为首之人略作思考，方才回应道：“大祭司那边一切如常，几位神使也都没什么异样。”</p><p>　　突然，为首之人像是想起什么来的，又补充了一句：“山神使今日同雨神使一起前往凫更城了。”那最高处又是一道声音传来：“凫更？鸤鸠，是你们白谷域边境外的那座小城？”</p><p>　　名为鸤鸠的主教微微欠身，拱手回应道：“回冕下，正是靠着白谷域边境的一座小城。它在山神使的管辖范围内，最近倒是没听说有什么反常之处。”</p><p>　　“玄鸟，青鸟，你们二人在圣鸾祭之后，就随着鸤鸠一起去白谷域那看看吧。”</p><p>　　“是。”</p><p>　　大乌西南·白谷域。</p><p>　　白谷域内，家家户户的门前皆挂着带有圣鸟图案的花灯，尽管已经过了戌时，域内的每条街道巷陌依旧处于白昼一般。每年举行完圣鸾祭，夜晚的白谷域居民都会挂上花灯祈福作乐。</p><p>　　不止白谷域，圣灵教所管辖的九域中，皆是如此。如潮水般的教徒纷纷从小楼深巷里涌出，沐浴在祭典后热闹喧嚷的氛围之中。正所谓弦管万家沸此宵，花灯万里正迢迢。</p><p>　　有人在街上感慨道：“今日的圣鸾祭，凤鸿冕下当真是威仪万千，可谓是有画难描圣威态，无花可比圣尊容。”</p><p>　　旁边的人一边附和一边感叹道：“我白谷域域主鸤鸠大人也是儒雅风流，真乃我白谷之幸。”周围的人纷纷点头，就听到人群中有人振臂揭喉高呼：“圣灵不朽！光耀万世！”“圣灵不朽！圣灵不朽！”一呼而万众应。</p><p>　　白谷域中央，怀桑殿。</p><p>　　一位身着紫袍的少年坐在殿内的一棵桑树下，低垂着头，将脸埋在树影之中。树干周围零星散落着几片枯叶，不远处是落满灰尘的高墙。</p><p>　　院墙内灯影幢幢，如鬼魅一般摇曳着。蓦地，殿外高呼的声音透过厚重的围墙，落在了少年的耳畔。</p><p>　　“圣灵不朽么…”少年浅语了一声，突然笑了起来。他一边笑着，一边抬起头，狭长的眼尾里，藏着揉碎了的黑暗。他拾起一片地上的落叶，任凭鲜血顺着手指将其染红。</p><p>　　少年怀中还抱着一名男子，一把玉质匕首插在那人的胸口，只余下一小截在体外。少年伸手想拨开那人额前的碎发，却不忍心手上的血渍沾上那人分毫。</p><p>　　他深深地凝望着怀中人的脸，浅浅勾了勾嘴角，眼底却是满堂的衰枝败叶。好一会儿后，他才将怀中的那人抱起，将额头轻轻抵在那人的额上，用尽所有力气般的深吸了一口气，然后缓缓地说：</p><p>　　“哥哥，你解脱了。”  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章 · 玉鸟望云雀🖤</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="玉鸟望云雀"><a href="#玉鸟望云雀" class="headerlink" title="玉鸟望云雀"></a>玉鸟望云雀</h1><p> 　　岁聿云暮,一元复始。</p><p>　　苏景托着脑袋，望向窗外的鹅毛大雪，想起了一个多月前，那道站在漫天银霜下的身影。他就那么直直地看着阴阳眼两兄弟的眼睛，仿佛生死于他而言，皆是虚妄。</p><p>　　后来，就变成了…打群架。苏景一只手死死勒住林七寸的脖子，双脚钳住他的下半身，另一只手对着林七寸的脸就是一顿猛揍，嘴里还不忘冲着他嚷嚷：“叫你偷袭！叫你偷袭！”</p><p>　　再后来，苏景就被白橖抱走了。白橖像抱着一只炸了毛的小奶猫，小奶猫还在气呼呼的吱哇乱叫。白橖勾了勾手指，一团团冰蓝柔光便敷在了苏景流血的位置。</p><p>　　白橖低头看了看苏景说：“瞎逞什么强。”苏景听完委屈极了，闷闷地说：“那个林七寸他想偷袭你！”白橖心里想着，他刚刚就察觉到了林七寸的小动作，正要应对的时候，便看到一个猫似的身影扑了过去。</p><p>　　白橖眸中泛笑，嘴上却淡淡地说：“知道了。”</p><p>　　“想什么呢。”苏景正望着窗外出神，耳边传来一道清冷的声音。“我在想，在想…这雪下的可真好看。”苏景看着白橖，有些支吾地说到。</p><p>　　“过几日就是除夕了，明日起我就回寺里去看望师父。你们有什么打算？”小和尚看着其他三个人问道。“我爹爹也喊我回去，说给我做一大桌好吃的！”虎妞儿一边眨巴眨巴眼睛，一边流着口水。</p><p>　　“你呢？”苏景看向白橖，目光中似乎藏着期待。“我…就在这。”白橖思索了片刻，师父这个月要闭关，他索性就待在这了，正好没什么人打扰，耳根子清…“太好了！今年终于有人陪我了！”白橖还沉浸在思绪中，就被一阵兴奋地声音打断。</p><p>　　他望着苏景合不拢嘴的笑容，不知为何，原本有些紧绷的弦悄悄地松了下来。</p><p>　　除夕，千家笑语，万户灯火。</p><p>　　白橖正在学府的藏书阁中随意地翻阅着。早上苏景跑来跟他说，今日要带他去一个地方。他有些期许，却又刻意将这份期许压在心底，藏在无人知晓的角落。</p><p>　　这时，一股轻盈的柔风自窗外悄悄溜到了他的身侧。先是调皮地蹭过他的脸颊，鼻翼，唇瓣，然后又勾起了他额前的几缕发丝，最后悠哉地来到他的耳畔，像是有人在耳边呢喃低语。</p><p>　　“跟我走。”</p><p>　　白橖听到了熟悉的声音，目光转向窗台，就看到苏景正扑闪着大眼睛，朝他勾了勾手。白橖心口生热，那些埋在心底的期许，刬尽还生。</p><p>　　渔火镇。江枫渔火，游子思归。</p><p>　　“这个小镇有来自各个地域的旅人。每年除夕，在外未归的游子便会在这里点燃一盏渔船的灯火，以寄归思。”苏景望着江畔来往渔船上亮起的灯火，向白橖介绍到。</p><p>　　白橖向四周张望着，金柳摇风树树，系彩舫渔舟遥岸。如织如梭的旅中客，燕舞莺啼的欢愉声，都和他儿时的记忆大相径庭。记忆里那个独自站在院墙一角的男孩儿，好像只有影子陪着他。</p><p>　　“噔。”蓦地，白橖耳畔传来一道钟声。他从思绪中走出来，却被一双温热的手捂住了眼睛。“三，二，一…”耳边有人在轻轻数着，然后徐徐松开手，漫天华光就这么映入他的眼眸。</p><p>　　“新年快乐！”苏景跳到了白橖身前，开怀着送上了新年的第一声祝福。白橖望着苏景，任凭人群熙攘，任凭霓光满天，他却只想把目光落在苏景身上。</p><p>　　“新年快乐。”白橖小声回应着。不远处，火树拂云起，琪花落满地。</p><p>　　冷泉亭外。泉水渟渟，风声泠泠。</p><p>　　苏景抱着几坛梅花酒，拖着白橖到冷泉亭这歇着。“你看，从这里望下去，正好可以将整个渔火镇看个清楚。”苏景找了个檀木柱靠着，又拉了拉白橖的衣角，示意他也坐下来。</p><p>　　白橖挨着苏景坐下，抬眼望去，灯火阑珊。他其实已经有些看不太真切了，哪怕这座亭子可以将整个渔火镇尽收眼底，在他眼里也不过是隔雾观火。</p><p>　　可是，他却觉得，他从未像今日这般看地真切过。</p><p>　　“小的时候，每年过年我都是和隔壁家的阿翁阿嬷们一起过的，他们待我很好，可我却总想着，要是能和我爹还有我娘一起就好了。”苏景仰头灌了一大口酒，小脸微红。</p><p>　　“后来，我爹和我娘把我带到了这里，他们跟我说以后这里就是我的家，可是每年我都见不到他们。偶尔他们会托人给我寄信，可是…”苏景坐起身，把头埋在柱子后面，白橖只能看着一张红扑扑的侧脸。</p><p>　　白橖把苏景从柱子后面拽出来，就听到了苏景小声的说：“我很想他们。”他声音很低，好像声音再大一些就会被别人发现他藏的秘密。</p><p>　　“这些年都是我一个人来这，但是今年不一样了。”苏景又灌了一口，一坛子梅花酒就见了底。他抬眼望着白橖，白橖也回望着他，似乎在这冬日的料峭里，能望见苏景眸中溢满的春水。</p><p>　　苏景将下巴浅浅地抵在白橖的肩上，嘴里呵出的酒气儿在白橖耳边打着旋儿。“今年有你陪着，真好。”苏景阖上眼，嘴角勾起了月牙般的弧度。</p><p>　　白橖的手在苏景靠近的时候，就下意识地抓紧了衣角。苏景说话间耳朵传来的酥麻让他手足无措，呼吸都乱了节奏。他怔怔地偏过头，看着苏景像只猫儿似的趴在他身上，眼底寒霜尽褪，心口春草疯长。</p><p>　　“小的时候我总是一个人躲在院墙的一角，没有人愿意接近一个连家主都讨厌的孩子。”白橖望着远处，陷入了回忆。“我养过一只小野猫，可是没过三个月它就死了，我很难过，把它埋在了后院的榕树下。”</p><p>　　“后来，我又养过雪兔，养过灵狐，养过许多许多的活物。它们同样都没活过三个月。慢慢地，我就不再难过了。”白橖自嘲般地浅笑一声。“我不喜这种感觉，这种感觉让我觉得…害怕。”</p><p>　　“再后来，我遇到了师父，师父是第一个待我好的人。他交了我如今修炼的心法，只是这心法虽强，却会导致我的身体比常人更加…敏感。”白橖说完，喉间有些干涩。他低头看了眼苏景，却发现他早已经在和周公举杯对酌了。</p><p>　　“傻子。”白橖无奈地摇摇头，在心里默默喊了自己一声。不远处，几瓣红梅也悠悠沉沉地落入雪的怀抱。</p><p>　　春潮带雨，润物无声。</p><p>　　立春甫过，苏景便整日神龙不见尾地不知道在忙些什么。有时是一整个上午不见踪影，下午便回到阁中呼呼大睡。有时上午坐在阁中也是心不在焉，下午又偷跑了出去。</p><p>　　白橖在忍了好几日之后，终于忍不住开口问他：“你近日到底在忙些什么。”语气中略微有些愠气。苏景看着他，眼珠子转了转，似乎在思考。又过了一会儿，他才一脸真诚地说：“秘密。”</p><p>　　就这样又过了两日。天刚蒙蒙亮的时候，苏景就蹲在白橖每日来学府的路上。小雨疏疏，青山欲晓，白橖来时见到的便是这般光景。苏景不知道横在路中央傻笑些什么，细雨润湿了他的发梢。</p><p>　　白橖走近了些，脚步略比往常重了几分。苏景听到脚步声传来，微微侧头，看到来人时，眼里放光地起身大喊：“白橖！生辰吉乐！”他张开双手，将白橖抱了个满怀。</p><p>　　白橖蓦地睁大了双眸，唇瓣微启，似乎想要说些什么，却呆呆地愣在原地。过了好一会儿，方才对苏景说：“你…站在这，我去取伞。”然后步子有些慌乱地朝学府走去。</p><p>　　苏景在学府门口晃悠了一会儿，就看见白橖拿着油纸伞，有些恍惚地走了出来。他跑过去，抓住白橖的衣角说：“走，我带你去个地方。”说完，往学府后山方向指了指。</p><p>　　两人徐徐走过后山的一片桦树林，又拐过几个崖角，来到一片木槿花丛。白橖停下了脚步，遥遥地就听到了几声啁啾。他举着油纸伞，偏头望向苏景。</p><p>　　苏景快步向前走了几步，然后从一块木槿花丛后面拿了两个金丝笼，笼子里面各有一只橙黄，橘红的玉鸟在欢鸣腾跃。“我看你袍子上绣的皆是玉鸟图案，便想着给你弄了两只来。”<br>　　<br>　　白橖望着笼中鸟，沉默不语。苏景将白橖的脸色看了个明白，然后毫不犹豫地打开了笼子。笼中的玉鸟先是不解的晃了晃脑袋，然后仰头望着天空，正巧几只云雀悠哉地掠过，便也挥着翅膀飞走了。</p><p>　　“它们虽然待在笼子里久了些，可是只要望向天空，便又有了方向。”苏景朝天上看了看，转头对白橖笑到。白橖有片刻的失神，他盯着苏景手中空无一物的金丝笼，呼吸开始变得急促了些。</p><p>　　苏景又带着白橖向木槿花丛后走去，一湾漾着碧波的池塘赫然映入白橖的眼帘，露花倒影，烟芜蘸碧。池塘周围铺满了青石，无名的野花交错着盛开，突然间，池塘里露出了两个小小的脑袋。<br>　　<br>　　“这是玉虚龟，它们寿命悠久，且极通人性，无论你什么时候想起来它们，它们都会在那里陪着你。”苏景望着白橖说到。“盛旦欣逢，愿君千万岁，无岁不逢春。这礼物你可喜欢，喜欢的话就笑笑吧。”</p><p>　　苏景先是抬手抱拳，眉间带笑地向白橖送上了生辰祝福。然后又凝眸注视着白橖，用最真诚的语气说：“遇到你，我很欢喜。”</p><p>　　白橖在听到苏景说第一句话时，神识就有些不受控制地波动了。当他听到“我很欢喜”四个字的时候，那些潜藏在心底的不安，那些冰封在雪山下的无助，都被那四个字击的粉碎。</p><p>　　他紧握双拳，似乎鼓足了所有勇气般的凝望着苏景，刚欲开口，骤雨溅珠。苏景连忙将他拉到一棵桦树下避雨。他没听到白橖刚刚说了些什么，急忙又问了一遍。</p><p>　　白橖没再说话，他看着苏景，第一次笑了出来。那一刻，雪尽春出，白橖眼眸里是倒映着的连绵春雨。</p><p>　　师父，您说的真的都对吗，可我好像和一个油嘴滑舌的家伙成了朋友呢。</p><p>　　锁在金丝笼中的玉鸟，也会想要扑腾着翅膀去追逐笼外的云雀。</p><p>　　那我呢。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 · 槐序起四时💜</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="槐序起四时"><a href="#槐序起四时" class="headerlink" title="槐序起四时"></a>槐序起四时</h1><p>　　仲夏的蝉鸣，将先生的讲学声拉的悠长。</p><p>　　苏景听着听着就打起了盹，梦里他正等着糖画师傅给他做一个玉鸟图案的糖画。一个胖乎乎的小手从后面拍了拍苏景的脑袋，将苏景的美梦赶走。苏景有些迷糊地揉了揉眼睛，就听见小和尚在他耳边大喊：“下学啦！！！”</p><p>　　苏景一激灵，一把将小和尚的嘴捂住。他看到白橖一直望着窗外，便问他：“今日天气这般好，要不要一起出去玩？”白橖没看他，只回了一个字：“热。”苏景非常理解地点了点头，拉着小和尚和虎妞儿出去了。</p><p>　　没过一会儿，正当白橖觉得耳根子清净了许多的时候，就看到窗外边一个火急火燎的身影朝他跑来，不一会儿就来到他跟前。他看着苏景从身后兴奋的掏出了一把竹制的油纸伞，然后用那双扑闪扑闪的大眼睛望着他说：“现在可以一起出去玩了吗？”</p><p>　　星霜荏苒，白橖就这样在学府待了近一个月。每天苏景都会变着法的给他带各种各样的新鲜玩意儿。尾生蓝光的水萤，吹不灭的永生火，能够听到潮汐声的清月螺，还有…苏景看着手里的含羞草，这东西和白橖简直一模一样。</p><p>　　两天前，虎妞儿和小和尚在追着玩，不小心撞翻了白橖桌上的茶水，茶水还冒着热气地淋在了白橖手上。苏景下意识的去握白橖的手，没成想，他刚刚碰到白橖的手指，就被推开了。</p><p>　　苏景有些委屈巴巴的把脑袋搁在桌子上。前段时间白橖心情好的时候还会和他出去走走，这几日因为那件事，白橖都不和他说话了。苏景发愁的叹了口气，突然又想起什么似的眼睛亮了起来，然后赶紧冲出门。</p><p>　　第二日，直到中午吃饭的时辰苏景都还没有出现。从早上苏景没来开始，白橖就时不时看向窗外。中午下学后，白橖朝小和尚看了一眼，还没开口，虎妞儿就抢着说：“苏景哥哥给你买东西去了！”</p><p>　　白橖微怔，过了好一会儿才说：“知道了。”小和尚奇怪地看了一眼白橖，不知为何，他总觉得白橖淡漠的语气里，藏着一分喜意。</p><p>　　午时，白橖照常用着一碗清粥。从小到大，他都以白粥为主，时蔬辅之。突然，一个雀跃的声音传来：“白橖！白橖！你看我给你带了什么！”白橖微微偏头，看到苏景猫似的蹿到他旁边，然后小心翼翼的拿出一个袋子。</p><p>　　苏景将白橖的碗挪到自己面前，然后从袋子里面倒入了一些暗红色的粉末，用木勺轻轻搅拌了之后，又挪到了白橖面前。白橖看着苏景一脸期待的眼神，又盯着自己的碗看了足足一盏茶的功夫，方才舀了一浅勺送入嘴里。</p><p>　　“咳！咳咳…！”白橖还未反应过来嘴里的味道，就被呛的咳出声来。苏景一脸惊慌失措，赶紧给他倒了一杯凉水，又轻轻的拍着他的背，担心的问到：“没事吧？”</p><p>　　白橖伸手去接苏景倒的水，食指不小心碰到了苏景的手背。他的手在空中静了片刻，然后继续面色镇定的拿过水，掩下喉间的灼热。苏景看着白橖咳地泛红的脸，有些心疼地解释到：“这是我从西蜀拿回来的辣椒粉，我看你每日喝清粥，就想着给你换换口味。是我考虑不周了。”</p><p>　　“无妨。”白橖将食指轻轻按在自己的唇瓣上，任凭灼烧感在唇齿间跃动。等这种感觉快要消退的时候，白橖又浅舀了一勺放入嘴中。就这么一勺，两勺…苏景看着他慢慢的将一碗粥吃到见了底，心中又惊又喜。</p><p>　　“你喜欢吗？喜欢的话我改日再给你拿一些来。”苏景像是自己吃到什么珍馐美味般的问到。“嗯。”白橖浅声应着。这是他第一次觉得，原来吃饭也会让他产生一丝期待。</p><p>　　金秋的麦浪，将少年的心一点点装的满满当当。</p><p>　　小和尚戳了戳眼皮子耷拉着的虎妞儿，神秘兮兮的问：“你有没有发现苏景和白橖最近有什么奇怪的地方？”虎妞儿用清澈的眼睛看了一眼他俩，然后说：“他俩越长越好看啦！”</p><p>　　小和尚翻了个白眼，然后指了指他俩的位置，悄咪咪的说：“他俩的椅子都要贴一块儿啦！”</p><p>　　十月十五，是学府进行比武切磋的日子。</p><p>　　学府后山，有一座巨大的比武场。苏景早早就拖着白橖和小和尚还有虎妞儿他们三个来到这里。苏景饶有兴致地冲他们三个说：“终于有机会好好教训那些眼高手低的家伙们了。”</p><p>　　白橖知道苏景嘴里的他们就是刚入学时出言讥讽他的那些人。从开学到现在，苏景已经明里暗里和他们较量许多次了。白橖眼眸含着一丝自己也不曾察觉的笑意，嘴上却说着：“幼稚。”</p><p>　　苏景看着越来越多的人往这边涌，便跟他们三个说：“我们往前凑凑，看的清楚些。”前段时间苏景发现白橖的眼睛似乎有些看不太清，他问过白橖是不是有哪里不舒服，白橖只回他没有，但他却在心里默默记了下来。</p><p>　　等所有人逐渐都到齐了，一位身着劲装的女子翻身上台，朗声喝到：“比武——开始！”</p><p>　　一名穿着朱红色袈裟，眼眸虚张，周身鸦青光晕沉浮的和尚立手走到台前，然后目光环视了一圈，最后停在了小和尚这里。“摈尘法师，请。”小和尚一脸嫌弃，但还是慢悠悠走上台，在离台还有六尺处停下时，明黄暗纹自脚底升腾。</p><p>　　“摒尘是普渡寺守真大师的小弟子，修的是梵钟普渡诀，梵音出，众生渡。”苏景向白橖介绍到。他又指了指小和尚对面的那个人说：“那是广济寺的慧远法师，师从宏悟大师。宏悟大师最拿手的便是大悲咒，不历大悲，不通极乐。”</p><p>　　白橖听完稍起了些兴致，只见小和尚周身笼罩在一个明黄古钟内，古钟上端是龙头钓手，下端有二个莲华形撞座。小和尚在古钟内紧锁双眸，左手持珠，随着嘴唇翕动的频率越来越快，一根龙型的钟椎赫然出现在古钟侧方，如巨龙吐息。</p><p>　　对面的慧远法师盘腿席地而坐，朱红色袈裟在肩侧环绕。他将胸口的紫金珠串取下，右手一下一下捻着，细看的话会发现紫金珠上有鸦青色纹路若明若昧。顷刻间，一位千手千眼的菩萨立于慧远身后，而其中一只手，遥遥对着小和尚的方向一指。</p><p>　　顿时，苏景听到了无数悲戚的声音在耳边萦绕，宛如杜鹃啼血的哀鸣。他立马运转神识，稳定心神。他又看向白橖，却发现白橖的眼睛里，平静无波，没有悲伤，也不曾欢喜。</p><p>　　小和尚没有坐以待毙，他突地睁开双眸，龙椎宛如巨龙咆哮似的撞上古钟。霎时间，震耳欲聋的梵音以小和尚为中心向四面八方扩散。明黄色的波纹和鸦青色的流光碰撞在一起，梵音与悲泣同鸣。</p><p>　　约莫半盏茶的功夫，笼罩着小和尚的古钟消失在虚空，立于慧远身后的菩萨像也变得若隐若现。“噗！”慧远法师在佛像消失的一刹那，捂着胸口，吐了一地暗沉的血。</p><p>　　小和尚用肉嘟嘟的手拍了拍自己的脸，摇摇晃晃的险些摔倒在地。苏景正准备去接他，突然眼神一凝，鎏色神识匿于虚空，一枚藏于阴影中的青针像是蛰伏在暗的毒蛇，随时准备给敌人致命一击。</p><p>　　“林七寸，收起你那些肮脏的手段。”苏景将小和尚扶起，目含鎏光的向人群中一处阴暗的角落说到。一道身着竹青色长袍，上面绣着蛇纹图案的男子缓步走上台，歪头朝苏景露出了一个轻蔑的笑容，他讥讽到：</p><p>　　“苏景啊苏景，你的神识除了能安抚两只阿猫阿狗，还能干嘛？”林七寸知道苏景还没有找到合适的心法，便处处踩着他的痛点。“臭扔针的！我拍死你！”苏景还未开口说话，就看见虎妞儿冲上了台。</p><p>　　一个巨大的月白色虚影遽然出现在虎妞儿身后，虎妞儿咆哮着向林七寸挥出拳头，身后的虎影也张开了血盆大口，虎掌带着排山之势向林七寸拍下。林七寸陡然瞪大了双眼，不敢有丝毫的分神，神识疯狂运转，竹青色浓雾向四周奔袭，无数青针藏于雾中。</p><p>　　虎掌拍向青雾时，只听雾中传来一声闷哼，接着便瞧见一道身影从雾中向后猛地退了好几步，方才堪堪稳住身形。虎妞儿双手叉腰，露着两颗小虎牙凶巴巴地冲林七寸喊到：“有本事你再叫啊！”</p><p>　　“你…！”林七寸正弯腰喘着粗气，听到虎妞儿的挑衅声，脸上有惊怒之色浮现。“别急，让我们兄弟俩来会会他们。”林七寸突然被一左一右两只手扶起，就见到开口说话之人朝他露出一个和善的笑容。</p><p>　　来的两人都只露出一只眼，另一只眼皆被黑布掩着。刚刚开口说话之人身着素衣，面容和善，而另一人全身裹在墨色长衫中，神情淡漠。</p><p>　　苏景见到上台的两个人后，目光一紧，旋即对虎妞儿说：“来的是阴阳眼两兄弟。哥哥执生，弟弟掌死。生死玄妙，皆藏于眼。你千万小心，不要看他们的眼睛。”虎妞儿听完，赶紧用两只小手把眼睛捂住。</p><p>　　苏景深吸一口气，眼帘虚掩，手掌翻转，金色暗纹自脚底浮现。正当他准备运转神识时，突然眼前出现了一道身影。白橖侧身站在他的身前，先是微微转头，用只有他听的见的声音对他说了句：“傻子。”然后又对着阴阳眼两兄弟用极其淡漠的语气吐出四个字：</p><p>　　“一起上吧。”</p><p>　　银霜漫天，雪虐风饕。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章 · 晨曦暖霜女❤️</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="晨曦暖霜女"><a href="#晨曦暖霜女" class="headerlink" title="晨曦暖霜女"></a>晨曦暖霜女</h1><p>  　　苏景和苏野一前一后走回房间。月光从窗外漫进屋内，留下一湾清浅。苏野借着月光将卷在地上的被褥收拾好，就看到苏景已经趴在床上翻他带回来的话本子了。他从桌前递过去一盏油灯，说：“少看一会儿。”</p><p>　　苏景嘟囔着应下。苏野又将他带回来的竹子在桌旁摆好，略微思索了片刻，便拿起小刀开始打磨竹子。没过多久，苏野就听到苏景“噗嗤”地笑出声来，他抬头望向苏景，就见他指着话本子里的一段话，摇头晃脑地念着：</p><p>　　“却说这两位少年，一位性格孤僻，一位直来直去。初识孤僻的少年还觉得直爽的少年惹人心烦，可是没过多久，两人却成了至交。欲知后事如何，且听下回分解。”苏景砸吧嘴，越读越觉得有些熟悉。</p><p>　　他翻了个身，一只手搁在脑后躺着，一只手将话本子盖在脸上。此时他的脑海里，出现了一位身穿水云绸缎，总是喜欢背着小手，一脸严肃的对他说：“别闹。”的人影。</p><p>　　大赢•凚玉山。</p><p>　　极北之地，雪山西来，横亘六合几千里。排云划雾，玉屑遮天，直控穹窿而特起。雪山尽头，凚玉山巅，一座殿宇巍峨耸立。</p><p>　　殿宇的西南角处，有一汪清泉，泉水上方暖雾缭绕，泉中有两只玉虚龟在慢悠悠扑腾。一名身着水云袍，头戴鹤羽冠的少年静坐在泉边的玉石上。少年用手指微微拨弄着泉水，冰蓝色的流光在指边跃动。</p><p>　　这里的温度极冷，一般人穿着狐裘大衣都会冻的直打哆嗦。可那池中的乌衣却似感受不到温度般地自在。少年听着泉中咕噜的气泡声，嘴角漾起一抹浅笑。</p><p>　　不远处传来一阵脚步声，一名年纪稍大的男子快步走到少年面前，对着少年说：“白橖小师弟，师尊唤我们过去。”名叫白橖的少年没有看他，仍旧冲着前方回应到：“师兄稍等。”</p><p>　　男子有些好奇的看了看暖泉，询问到：“这里面就是师弟寻了好久才找到的阳烁石？”白橖点了点头。“原来是置于这方泉水之下，有阳烁石在，这两个小家伙才能这般快活。”男子指了指泉中的乌衣，略作感慨。</p><p>　　白橖收拾好了自己的衣裳，正欲起身，男子连忙跑过去搀扶。白橖退了一步，清冷地说：“无妨。”男子有些担忧地说：“你的眼睛…”白橖摆了摆手，似乎是自言自语地说：“眼见不一定为实，心见才是。”说罢，便自己朝殿门外走去，眼底升起一片雾霭。</p><p>　　凚玉山有十二宫，从白橖居住的宫殿到师尊住的正殿要经过另外几座行宫，里面住的是其他师兄弟。刚刚唤白橖的那位师兄也陆续唤了其他人。他们三三俩俩的结伴而行，只有白橖独自一人走在最后。每次人一多起来，白橖就会想到那个人的身影。</p><p>　　那是崇宁十二年的夏天，同样的硝烟遍地，山河飘摇。</p><p>　　白橖的眼睛从那个时候就逐渐有些看不清了，可他却觉得正是从那时起，他才真正拥有过光明。</p><p>　　那一年，师傅将他送到了三国交汇处的一座山谷。谷里有一座学府，名“鼎泰”，有鼎立三足，三阳交泰之意。里面全是江湖各派送去的天赋异禀的孩童。因其独立于任何一方势力，方才能在这乱世中超脱于外。</p><p>　　鲜有人知道府主是谁，也很少有人知道府里的先生来自哪里，大家都心照不宣的将门中优秀子弟送来进修，因为这里不论国界，不论尊卑，只论天赋。</p><p>　　大赢的三教九流能和世家子弟同席而坐，乌人眼中的异教徒也能与圣灵教和巫神教同台论道，还有乾国数不清的小部落，在这里也能和二十八宿部的裔子们一决高下。</p><p>　　这里有失传已久的大赢心法和身法绝学，也有来自上古的乌族术式，还有乾国蛮荒时期的血脉秘术，原本这些握在各国勋贵手中的宝藏，却在这里被传授给来自不同背景的孩童。</p><p>　　三国的掌权者对此地虎视眈眈，却又因为厉害关系相互制肘，没有谁愿意率先打破这个微妙的平衡。一双无形的手悄悄藏于这座学府的背后，能托之，亦能覆之。</p><p>　　刚来此地的白橖并不关心这里有谁，也不关心为什么随处可见奇装异服的男女老少。师父他老人家在他下山前，苦口婆心的劝到：“橖儿，此次下山，为师希望你能多交些朋友回来。当然，油嘴滑舌的家伙除外！”白橖点点头，记下了师父的话。</p><p>　　苏景正带着一个胖胖的小和尚还有一个虎头虎脑的女娃娃准备去府外斗蛐蛐儿，就看见府门口一个粉雕玉琢的小男孩儿背着小手，默默凝视着府上的“鼎泰”二字。</p><p>　　苏景以为他不识字儿，就热心肠的跑过去，大声的冲小男孩儿说：“这两个字念‘鼎泰’，一言九鼎的鼎，否极泰来的泰。”说完，还不忘朝他眨了眨眼睛。苏景以为小男孩儿会对他投来崇拜的眼神，没成想，小男孩儿看都没看他一眼，只是微微吐出两个字：“傻子。”</p><p>　　苏景也不生气，他一脸好奇的问小男孩儿：“你叫什么名字。”男孩儿不做声。苏景又问：“你家在哪？”男孩沉默不语。苏景不屈不挠：“你要不要和我们一起斗蛐蛐？”话音刚落，男孩儿头也不回的走进学府，留给苏景一个冷漠的背影。</p><p>　　小和尚贼兮兮地凑过来，说：“依小僧看，他定是嫌你话多。”虎妞儿睁着大眼睛，望着小男孩儿离开的背影说：“他生的可真好看。”苏景灰溜溜的摸了摸鼻子，说：“可不是。”也不知道是在回复谁的话。</p><p>　　第二日清晨，学府的学生们坐在阁内，等着先生来上课。还未到时辰，底下叽叽喳喳的乱成一片。不一会儿一位须发皆白，精神矍铄的老者带着一位身穿水云袍的小男孩儿走到台前，清了清嗓子说：</p><p>　　“今日学府中来了位新门生。来跟大家做一下自我介绍。”说完，老者示意小男孩儿上台。小男孩儿略微有些拘谨的走到台前，一脸严肃的说：“我叫白橖，师从凚玉山寒丹尊者。”说完，又径直退到一旁。</p><p>　　苏景在白橖进入阁中的那一刻起，就一直悄悄注视着他。他的衣服上绣着精致的玉鸟图案，明明年纪和他一般大，却总是像个小大人似的一直皱着眉头。苏景觉得，他要是笑起来，一定比虎妞儿还漂亮。</p><p>　　他听到白橖的名字时，满脑子想的都是糖霜，糖人，糖画…虎妞儿露着两颗小虎牙，憨态可掬的望着白橖…流口水。旁边的小和尚看到苏景在白橖介绍完后莫名其妙的傻笑起来，又看到虎妞儿发呆的样子，摇了摇头，捻了捻手里的珠子，低头念了句：“阿弥陀佛。”</p><p>　　突然，阁内传来一声冷哼，接着便听到有人讥讽到：“我当是谁，原来是寒丹尊者的爱徒，大赢白家的少主啊。”阁中其他人先是一愣，在听到白家少主几个字后，面色皆古怪了起来。</p><p>　　大赢白家，数年前因为“卖国求荣”的罪名，家主被下到昭狱。“白家子怎么还敢有脸上这里来丢人现眼了？”又是一道不屑的声音从阁中响起。白橖似是没听到那些个嘲讽，衣服的一角却被小手轻轻的抓起，空气中有寒霜悄然凝结。</p><p>　　阁中霎时间静的出奇。突然，“我叫苏景，同你一般大，来自西蜀苏家。”苏景突然站起身，朝白橖露出了一个盎然的笑意。“咱们这不论出身，只比拳头。谁拳头更硬，谁就是老大。”</p><p>　　苏景有意无意的朝阁中的某一个角落看去，又朝白橖招了招手，说：“来我这儿坐！我这边靠窗，凉快！”白橖淡淡地朝苏景望了一眼，在心里吐了两个字：“傻子。”他环视了阁中一圈，似乎只有苏景旁边看着稍微有些顺眼，便径直朝他那走去。</p><p>　　苏景赶紧将旁边位置上画的木槿图收拾了干净。白橖没有看苏景，自顾自的越过苏景坐在窗户旁边。他将椅子往窗边又挪了挪，开始闭目养神。苏景把椅子也往白橖那挪了挪，看似有模有样地望着先生，眼睛却不住往窗边瞟。</p><p>　　白橖眼眸微闭，神识却泛着冰蓝的柔光。他想起师父临行前告诫他的话，略微思索着，想必苏景就是师父口中那种油嘴滑舌的家伙吧。</p><p>　　窗外，晨曦东升，万物尽苏。昨夜青女带来的凝霜和寒意在此时悄然化成了水汽儿。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四章 · 总角孝古稀🧡</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="总角孝古稀"><a href="#总角孝古稀" class="headerlink" title="总角孝古稀"></a>总角孝古稀</h1><p>  　　苏景和苏野两个人在王爷爷家门口等了一会儿，月光温柔的将两个人的影子拉的纤长。苏景往前挪了挪步子，让他的影子悄悄盖过了苏野的头顶。他又伸出手往左边拍了拍，苏野就看着苏景影子里的手拍上了自己影子的脑袋。</p><p>　　苏景自顾自地在旁边傻笑着，没过一会儿就听到屋里传来一个中气十足的声音：“走了小兔崽子们！”未见其人先闻其声。眨眼间的功夫，一位鹤发童颜的老者就迈着大步走了出来。</p><p>　　这位老者先是盯着苏野看了一看，然后随手取下腰间挂着的一个小葫芦瓶，扔给苏野说：“你小子今日目萦厉煞，周身血气浮动，我这瓶子里有三十六颗清心丸，你每日卯时服下一颗，足月方可除煞。”</p><p>　　苏野接过葫芦瓶子，微微点了点头。老者又望向苏景，发现苏景正略带期待的看着他，便从药盒里取出两颗丹药，神色严肃地说：“小小年纪就不好生养胃！整日吃辛辣喝烈酒，胃早晚给你折腾坏了！回去以后，将这枚养胃丹用温水化开，早晚各服一次，不许再喝酒了！”</p><p>　　苏景连忙点了点头，嘴里一边说着：“谢谢王爷爷！我保证滴酒不沾！”一边冲苏野使了个眼色。苏野心领神会，将拎着酒罐子的手往身后背了背。王爷爷这才满意的说；“走吧，去瞧瞧你们奶奶的病。”</p><p>　　苏野跟在苏景身后三个步子的距离，看着苏景像只小麻雀似的和王爷爷唠着嗑。经过四五个拐角，又辗转了几条野路，一个翠竹环绕的的竹楼出现在三个人的眼前。</p><p>　　苏野快步上前去把门打开，点燃起厅堂的蜡烛，然后领着王爷爷进到屋子里。苏景三步作两步地跑进来，大喊着：“奶奶，我们回来了！我们还把王爷爷请来了！”</p><p>　　里屋传来一个慈蔼的老妇人的声音，略带笑意的回应着：“回来就好，回来就好，快进来坐。”苏景和苏野便带着王爷爷往里屋走。刚进门，苏景就看到奶奶准备起身。他赶紧跑过去将奶奶扶起来，苏野也从背后递来一个枕头放在奶奶的腰后。</p><p>　　奶奶先是冲着苏野和苏景笑了笑，然后转头对王爷爷略带歉意地说：“王觋医，又要麻烦你了。”王爷爷摆了摆手，轻轻捻了捻自己的山羊胡子，说：“不麻烦。两个小兔崽子，在外面侯着去！”</p><p>　　苏景乖巧的眨了眨眼睛，对奶奶说：“奶奶，我和苏野今日给您抓了条大鱼！我们现在去做给您吃！”奶奶宠溺地对苏景点了点头，又对苏野说：“看着他点，别让他把厨房掀了。”苏野浅笑着应了好，就拉着苏景出去了。</p><p>　　两个人一起来到厨房，等苏野将厨房里的火烛亮起的时候，就见到苏景在门边徘徊着。苏野知道苏景在想什么，便对他说：“你去把酒和牛乳温着，其他的事情我来。”说罢便将竹篓里的彩鳞鲭拿了出来。</p><p>　　苏景赶紧应了苏野的话，然后跑出去温东西了。苏野知道苏景的神识有共情万物的能力，虽然彩鳞鲭灵智微乎其微，可是苏景仍然可以感受到它的痛苦。所以一般杀生的事情都是他来做。</p><p>　　苏野想到有一次他和苏景上山采灵药，路过一片灌木丛时他不小心踩死了一只木栖虫，身后的苏景几不可闻的发出了一声闷哼。尽管苏景连神情都没有变化，但是苏野还是敏锐的捕捉到了苏景的感受。</p><p>　　苏野娴熟的将彩鳞鲭处理好，然后下锅煮沸。苏野其实不喜欢吃鱼，他吃惯了牛羊肉这种粗肉，鱼这种细肉他吃的不自在。苏景也不喜欢吃鱼，他生性好动，吃鱼对他来说太麻烦了，好几次险些被卡住。</p><p>　　但是奶奶喜欢吃鱼，所以每隔一段时间两人就会捉一条鱼回来做给奶奶吃。所以苏野在做鱼这块也是相当熟练的。等鱼做好了，他又给苏景炒了两盘小菜，然后准备去叫苏景。</p><p>　　苏景在竹楼外升起了一堆柴火，他小心翼翼将装牛乳的罐子固定好，然后拿着个蒲扇轻轻扇着火。晚风阵阵，火光曳曳，苏景没来由的生出些困意。他扇风的手越来越低，速度越来越缓，在快要停下的时候，听到有人轻唤了声“苏景。”</p><p>　　苏景反应了片刻，猛的抬起头，拿扇子的手不小心碰到了烧的发红的罐子。苏景被烫的下意识缩回了手，却将那罐子晃荡了起来，洁白的牛乳随着晃动洒了些许。苏景又想伸手去稳住晃悠悠的罐子，却看到有双手从身后伸了过来，稳稳的拿起罐子放在了地上。</p><p>　　苏景转头，看着苏野面色不虞地盯着他。他有些不好意思地挠了挠头说：“对不起，我不小心睡着了，牛乳撒了一些…”话音刚落，苏野就将苏景的双手握住，然后低头在泛红的地方吹了吹。</p><p>　　苏景刚想说他没什么事，就听到苏野有些闷闷的质问他：“手不想要了是不是。”接着没等他回答又问道：“酒呢？”苏景指了指放在火堆后的酒罐子说：“没事，我喝冷的就行。奶奶那应该弄的差不多了，我把鱼给送过去。”</p><p>　　“菜我已经送过去了。酒我给你温，不着急。”苏野拉住想要起身的苏景，然后去将酒罐子架在火堆上放好，又新添了几根柴火，最后默默坐回苏景身边，没有说话。</p><p>　　苏景有些不自在地拨弄着手边的杂草。一盏茶的功夫后，苏景看到王爷爷背着药箱出来了。他赶忙起身询问道：“爷爷，奶奶的腰怎么样了。”苏野也站了起来，拍了拍苏景背上的灰尘。</p><p>　　“腰痛暂时是不会发作了，但她早年间从山崖下摔下来摔的太狠，年轻的时候又没有好好治疗，导致现在成了隐疾。我这段时间先封住了她的痛感，不过想要更好的缓解她的腰伤，需要到镇上去买些药材。”王爷爷解释到，然后递了张药单给苏野。</p><p>　　苏野将药单收好，对苏景说：“你先回去吃饭，我去送送爷爷。”话音刚落，就看到王爷爷自己自顾自的往外走，嘴里念叨着：“老头子我好得很，不用你送！你俩都饿坏了吧，赶紧去吃饭！快去快去！”</p><p>　　苏野和苏景对视一眼，都看到了对方眼里的笑意。他俩一人拿起一个罐子，朝屋里走去。进门的时候看到奶奶正好从里屋走出来，他俩放下罐子，将奶奶扶到桌子边上坐好。</p><p>　　苏野去厨房里准备拿两副碗筷。苏景问奶奶：“奶奶，鱼好吃吗？”奶奶眼睛里溢满了笑容，她止不住的夸赞着：“好吃！小野的手艺是越来越好了！将来娶的媳妇儿定是个有福气的！”</p><p>　　苏野从厨房出来的时候正好听到了奶奶的话。他先是递给了苏景一副碗筷，然后无奈的说到：“奶奶，您就别打趣我了。”说完，眼睛有意无意地瞟了苏景一眼。苏景没有说话，只是望着奶奶浅浅地笑。</p><p>　　苏野给苏景倒了碗梅花酒，又盛了两碗牛乳。苏景喜欢喝酒，越烈越兴奋。苏野却喜欢牛乳，越纯粹越合口。奶奶笑着接过苏野递的牛乳，对他俩说：“你俩都是好孩子。当初我从山上将你们带回来，一晃眼就是五年。”</p><p>　　“你俩当时见着我，一个眼睛水汪汪的，一个像头小狼崽子，凶得狠。当时我就在想，我的孙子要是还活着，也和你俩一般大了吧。”奶奶笑着说到，眼里却噙着泪。</p><p>　　“我看着你俩身上全都是伤，心里啊就跟揪着似的。两个这么小的娃娃，到底是吃了多少苦。”奶奶一边说一边抹着泪，苏野没说话，他静静地看着苏景把头低的越来越下，眼睛没进了阴影。</p><p>　　“我说带你们去治病，小野还不情愿。最后还是小景拖着拽着你走我才把你俩带到了王觋医那。”“王觋医看过你俩的伤，偷偷跟我说，要不是这俩孩子命大，就凭他俩身上的伤，不死也要没了半条命。那时我就下定决心，要让你俩在我这里住着，住到我老了，哪都去不了的时候，就换你们来照顾我。”</p><p>　　“三年了，我早就把你们当成了我自己的孩子。我不知道你们有没有把这当成自己的家，但是只要奶奶我还在这里一天，这里就永远是你们的家。”说完，奶奶缓缓起身，先拍了拍苏野的手，又顺了顺苏景的头发。“时辰不早了，早点回房歇息吧。”</p><p>　　苏野起身将奶奶扶回了房间。再次回到桌前的时候，发现苏景正红着眼眶，用一双湿漉漉的眼睛看着他。苏野走到苏景旁边，蹲下身子，抬头捏了捏苏景的脸，柔声说：“我会一直陪着你的。”</p><p>　　苏景看着苏野，没有说话。苏野知道他刚刚听了奶奶的那番话，心里一定酸楚的厉害。苏野也不好受，默默在心里盘算着要怎么去镇上给奶奶买药。他站起身，计划着明天就去深山里找些珍稀的灵药，再拿到镇上去换。</p><p>　　就在此时，一道带着哭腔的声音认真地对他说：“我也会一直陪着你的。”苏野心下一怔，然后直勾勾地望着苏景的眼睛，胸口发烫。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 · 芳醴入暖酥💛</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="芳醴入暖酥"><a href="#芳醴入暖酥" class="headerlink" title="芳醴入暖酥"></a>芳醴入暖酥</h1><p>  　　苏野站在一片乾阔的竹林内，这里生长着两种截然不同的竹子，骨竹和绵竹。骨竹叶繁而节疏，色苍而气凛。棉竹猗猗，叠干龙回，攒根凤峙。每次苏野心情不好的时候，便会到这里砍些竹子回去做些小玩意儿。</p><p>　　这些年苏野一直试图寻找能够清除疤痕的药材。可是附近的村庄只有几位年迈的觋医和巫妪，治伤可以，却没办法让苏景彻底恢复。他想起苏景腿上成片的烧伤，还有手臂上密密麻麻的刀痕，五年前的记忆纷沓而至。</p><p>　　他记不清那是白天还是夜晚，也不记得自己在那里趴了多久，他只记得全身不断传来的疼痛一点点摧毁着他的意志，内心深处有一片深渊试图将他拽入无尽的黑暗。夏日天气燥的不行，可他还是觉得冷，冷的骨头发颤。</p><p>　苏野觉得自己快死了，他从大乾北部一路逃到了这里，从尸山血海逃到了青山碧谷。这里只有他一个人，溪流涓涓的声音好像离他越来越远。模模糊糊中他似乎听到了熟悉的声音在唤他：“小野…小野…”</p><p>　　突然，一股夜交藤的清香钻入他的鼻翼，耳畔边也传来一串串风铃似的低吟声。苏野的神识稍微清醒了几分，感觉自己仿佛置身于温泉暖池当中。“是谁在麻痹自己的五感？”苏野心道，可是他没有多余的力气去探个究竟，只能任凭来人摆弄。</p><p>　　又过了一会儿，当苏野再次感受到睡意如潮水般涌来时，一根微凉的手指覆上了他的唇瓣。他还未来得及琢磨唇上的凉意，就发现这根手指试图撬开他的嘴。苏野心中有些好笑，第一次有人主动把手伸进狼嘴里，不怕他一口给咬断吗。</p><p>　　苏野起了逗弄的心思，任凭那根手指如何使劲儿，苏野都紧抿着唇瓣。正当他以为那人没招的时候，耳边忽的传来一阵温热，还没反应过来话中的含义，腹部便被轻飘飘的打了一拳。</p><p>　　苏野明白过来，心中轻笑，假装吃痛地张开嘴，好奇来人要对他做些什么。张开嘴的瞬间便感觉到一滴滴带着血腥味的液体落入唇缝。苏野不明所以，可是没过一会，苏野就惊愕的发现自己竟然可以控制身体的内力了，再然后他就陷入了梦中。</p><p>　　浑浑噩噩之间，他感觉到有人想要带他离开。他慌慌张张地将右手用力的插进泥土里，不想让藏起来的戒指被人发现。这时，右手上又传来一阵熟悉的凉意。苏野有些意外，却也由着他背着自己离开。离开前，他似乎感觉到那人不着痕迹的抖了一下，嘴角泛起一丝笑意。</p><p>　　他由着那人将自己带到溪边，又由着他给自己处理伤口。他感觉到那人在看到他的后背时，指尖微微的颤抖。“吓着他了吗？”苏野心里想着，却发现那人有条不紊的清洗着他的伤口。</p><p>　　再然后…苏野记不清了，只记得自己被那人弄的浑身痒痒，伴随着溪水潺潺的声音睡过去了。又不知过了几日，迷糊中他想起了自己小时候珍藏的猎物，他喜欢抱着他们睡觉，那是属于他自己的战利品。他下意识的轻咬着身旁软软的东西，心满意足的酣睡着。</p><p>　　在一阵窸窣声中，他惊醒过来。这是他这么长时间以来，第一次有力气睁开眼睛。映入眼帘的是一张少年的脸，少年白皙的脸上满是…害怕？苏野不理解的看着他捂着脖子，突然想起来自己昨天晚上似乎咬着什么。</p><p>　　他默默地走到少年身边，假装什么都没发生似的轻轻咬了咬他的手臂，然后倒下去装睡。似乎是在暗示少年自己不会伤害他。少年没有挣扎，而是默默坐在自己身边，哼着小曲儿。苏野感到从未有过的放松，但是心底却升起一股不安。</p><p>　　又过了好几日，半梦半醒间苏野好像回到了一片血泊之中。血泊中一个男人双目猩红，周身血光弥散，他凄厉的地对着自己喊：“小野！小野！”苏野猛的惊醒，想要找到自己带着的那枚戒指。</p><p>　　他发了疯似的满地寻找着，指甲掀起一层又一层的泥土，鲜血顺着手指汩汩流进土壤里。突然他听到了一阵急促的脚步声，一只握着戒指的手伸到了他面前。他焦急的把戒指抢了过来，恶狠狠的盯着抢走戒指的那个人。</p><p>　　当他回过神看到来的人是谁时，才陡然清醒。他有些局促和不安的将自己蜷缩起来，闭上眼睛想要甩掉脑子里的血泊，却怎么也忘不掉。他烦躁的喘息着，却发现有只手一下一下的轻拍着自己的后背，好像知道自己没睡似的不停安慰着。</p><p>　　他的心霎时平静下来，等着那人的手拍的越来越轻，直到搭在他的肩上睡着了。苏野睁开眼睛，起身仔细打量着眼前这个人。他先是被那人满身的破烂衣裳吸引，衣裳上的花纹繁冗华贵，如今却如粗麻烂布似的挂在那人身上。</p><p>　　苏野视线往下，看到那人的腿被包裹的严严实实。只有脚踝处的地方，微微露出来一小片肌肤。苏野面色微沉，他看得出来那露出来的一小部分已经是烧伤过刚长出来的新肉，可想而知，整个腿部应该都伤的不轻。</p><p>　　苏野又低头看着搭在自己身上的手臂，上面是一条一条带着血痕的刀口。苏野想起了自己嘴巴里的血腥味，便猜到了这些伤痕的缘由。他用拇指的指肚来回拭过那些刀口，像是在拭着白瓷上的裂痕。“七十一道。”苏野默默的把这个数字藏在心底。</p><p>　　最后，苏野望向那人的脸。乱糟糟的头发下面是和羊脂玉一般白皙的脸。他的睫毛让苏野想到了枝繁叶茂的蓝花丹，鼻梁让苏野想到了壁立千仞的九嶷山，嘴唇让苏野想到了…咳，苏野收回自己越飘越远的思绪，开始仰头数着天上的星星。</p><p>　　“一，二，三，五，六，十…不对，一，二，四，五，七…不对不对…”苏野望着天上的星星，不耐烦的胡乱数着。他从小就讨厌数算，如今心里燥热，更是没法好好数了。</p><p>　　就在这时，一道细微的闷哼声传入苏野的耳朵。紧接着就听到那人带着哭腔小声喊着“爹爹…娘…白糖…”苏野低头看着那人有些颤抖的身体，长长的睫毛上面挂着泪星子，像是清晨悬在叶上的露珠，颤巍巍的。</p><p>　　苏野从来没有安慰过人。他学着那人之前拍他一样，也略带僵硬地轻轻拍着那人的肚子，嘴里念叨着：“没事了，都没事了…”他不知道自己为何要这么做，但他现在就是想这么拍拍他，又像拍着自己。</p><p>　　就这样又过了两日。那日的阳光格外明媚，亮的那人睡觉都不太安稳。苏野看着那人在阳光下微皱的眉头和被阳光晒的红扑扑的脸蛋，鬼使神差的伸出手，替他遮挡着脸上的阳光。</p><p>　　苏野就这么静静地遮了两个时辰，直到那人的眼皮颤了颤，他才回过神似的慌忙收回自己的手，眼睛却来不及从那人脸上挪开。于是，那人睁眼的刹那，他直勾勾的看向那人的眼眸深处，像是望见了天上的骄阳，腾的在他心里燃起了一片烈火。</p><p>　　苏野从未如此渴望的想要了解一个人。他深吸了一口气，缓缓低下头，伏在那人耳侧，努力压下喉中的那股燥热，问到：“你是谁，为什么要救我。”他想知道一个答案，哪怕只是那个人的名字。</p><p>　　“我叫苏景，我想救你。”只听那人毫不犹豫的回答着他。又听他反问：“你叫什么名字？”苏景没有问他为什么会来这里，只是好奇他叫什么。“我叫…苏野。”“你也姓苏？！那我们就都是苏家的人了！”苏景高兴的喊道。“…嗯。”苏野不置可否，眼底也含着笑。</p><p>　　竹子砍的差不多了，苏野从回忆里面抽离出来，天空悄悄地泼了墨。他一手抱着竹子，一手拎着竹篓，用最快的速度疾驰回家。回家的路上，他经过了两家铺子，然后往王爷爷的方向奔去。</p><p>　　当苏野赶到王爷爷家门口的时候，他突然停下了脚步。眼前的石凳上，苏景背对着他坐着，两条腿悬在空中一下下的摆动着。听到他的脚步声，苏景转过身来，对着他露出了一个大大的笑容，然后举起手向他这边晃了晃，对他说：“苏野！我在这！”</p><p>　　苏景从石凳上跳下来，边跑边跟他说：“我已经跟王爷爷说了奶奶的事儿。爷爷现在在收拾东西，我们等他一会儿。”等苏景跑到他身边，苏野瞧着他从身后拿出了一个罐子，略微有些得意的跟他说：“你瞧我买了什么。新鲜的牛乳！还温着，咱们一会儿回家喝！”</p><p>　　苏野心头微热，也从背后伸过手，拿出一个装着梅花酒的酒壶，又从兜里掏出一个话本子。他盯着苏景认真地说：“我们回家。”</p><p>　　蝉鸣几许，繁星明灭。奶味儿混着酒香，纯真与热烈碰撞。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 · 朱阳煜微烛💚</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="朱阳煜微烛"><a href="#朱阳煜微烛" class="headerlink" title="朱阳煜微烛"></a>朱阳煜微烛</h1><p>  　　苏景的神识直到看着苏野转身朝竹林的方向离开后才暗自收回，夕阳的余晖将他回家的路照的金黄。他知道苏野要去竹林做什么，可他现在也想为苏野做点什么。</p><p>　　太阳是最富有的神明，他慷慨的将晨曦，将暮色，将晚霞赐给每一片山林。山林亦是毫无保留的将这份恩赐传递给生长在这里的一花一草，传递给行走在其间的每一位有缘人。</p><p>　　苏景就是这样的有缘人。他喜欢走在日暮下的山林，不，他也喜欢清晨的山林，雨后的山林，槐序的山林，岁馀的山林。他喜欢一切的山林，也喜欢山林的一切。</p><p>　　往常回家的时候，苏景总是会不自觉的在这片林子里多待上一会儿。仲春的朱顶红，槐序的虞美人，金秋的迷迭香，岁馀的蝴蝶兰，都是苏景的玩伴。前些日子天气好，苏景每天都要待到晚饭的时辰才回去。</p><p>　　今日的天气比前几日的天气还要好上几分。夏风骀荡，苏景觉得自己应该更高兴些才对，可是苏野背后的疤痕在他脑子里面挥之不去。他一遍遍的回想着，没心情去管今天的天气如何，更没心思去想他的话本子。</p><p>　　回去的路上要经过三十六道弯，而在最后曲径通幽的地方，有一片村庄，那里就是苏景的家，也是苏野的家。苏景有个习惯，经过了多少道弯就在心里反复念叨着这个数，数越大苏景走的越快，数到三十六的时候苏景已经是连走带跑的往家里赶了。</p><p>　　但是今日的苏景已经记不得他数到几了。他的步子迈的比往日都要慢上一些，将脚底的树叶残枝踩的吱呀呀响，神思涌动，脑海里面回忆起了他和苏野第一次相遇的场景。</p><p>　　三年前的一个晌午，苏景一个人在望日峰上待了许久。大半个月以来，他每日都要花好几个时辰的功夫坐在望日峰最高的那棵千年龙柏的树冠上，看飞鸟缱绻在云缕，看池鱼氤氲在碧涧，看薰风吹拂新绿，看露雨泽润青茵。</p><p>　　苏景喜欢这般的日子。他轻轻阖上眼睛，鎏色的光晕在眉目间流转，神识慢慢的从眉宇向四周蔓延。神识所过之处，空气中弥漫的燥热皆被抚平退散。</p><p>　　他的心念随着神识漫无目的地闲逛着，在快要溜达到这片林子外的时候，突然觉察出一道近乎微弱的喘息。苏景心中隐隐感到一丝不对劲，立刻将散漫开的神识向那道喘息声的方向聚拢。</p><p>　　当苏景的神识拢在喘息声传来的那处地方时，他看到了一个和他年纪相仿的少年浑身是血的趴在地上。少年眉头紧锁，眼帘低垂，嘴唇苍白，身体似乎因为太过疼痛而轻微的颤抖着，那一道道似有若无的喘息声让苏景觉得他随时都有可能被灌下两大碗孟婆汤。</p><p>　　苏景赶紧从龙柏上跳下来，火急火燎的朝受伤的少年那赶去。他的鞋不太合脚，跑起来总是有些磕磕绊绊。途中苏景的肚子不争气的叫了一声又一声。苏景管不了那么多，顺手摘了几个看起来能吃的果子就揣进自己身上唯一一块儿还称得上干净的地方。</p><p>　　等苏景赶到的时候，少年的气息已然又微弱了几分。苏景意外的看到，少年原本空荡的尾骨处不知何时生出了一条玄青色狼尾，只是这尾巴也同他主人一般，像霜打的茄子，软塌塌的倒在一旁。</p><p>　　“这是…狼族？连人形都已经没法完全维持了，看来伤势真的挺严重。”心念及此，苏景顾不得多想，眉头微蹙，赶紧释放神识将少年笼罩在其中，同时心中密词默念，一道裹挟着夜交藤香的软风自苏景处落向了少年的眉心。于此同时，一串如江南小调般的低吟声传进了少年的耳畔。</p><p>　　苏景一边维持着“安神诀”，一边分神仔细观察着少年的反应。只见少年颤抖的身体随着耳畔的低吟声逐渐平静下来，紧锁的眉宇也舒展了几分。他的呼吸声不再断断续续，而是浅浅的起伏着。</p><p>　　苏景看着少年浑身上下没有一处完整的衣料，露在外面的身体满是凝固的血痂和数不尽的刀口子，狰狞的刀口上沾满了污泥和血垢。苏景不知道少年经历了什么炼狱般的痛苦，但他能感觉到自己的心被一只无形的手紧紧攥住。</p><p>　　苏景轻吐了口气，他的神识具有宁心静气的作用，“安神诀”也能帮助缓解疼痛。然而无论是苏景的神识还是“安神诀”都只能起到镇痛宁神的效果，这种治标不治本的法子虽可以短暂缓解少年的痛苦，但想要把他从鬼门关拽回来，只能…</p><p>　　想到此处，苏景毫不犹豫地伸出左臂，拢起袖子固定好。右手幻化出一道风刃，在左臂的动脉处深深地划了一道豁口，豁口裂开的瞬间，鲜红的血液随着苏景倒吸一口凉气的声音缓缓流出。</p><p>　　苏景小的时候养过一只奶猫，有一次它不小心误食了一种致命的毒果子，苏景发现的时候它腹痛的在地上不停的翻滚。苏景将它抱在怀里，正准备动用神识，不料手掌传来一阵刺痛。苏景看到小奶猫不小心划破了他的掌心，又将渗出来的血舐了干净。</p><p>　　接下来发生的一幕让小苏景瞪大了眼睛。他惊讶的发现，原本已经快要不行的小奶猫竟然恢复了精神，乖乖的躺在他怀里睡着了。苏景用神识探查了它的状况，虽然还是虚弱的很，但是已然没有大碍。</p><p>　　小苏景愣愣地看着自己的手掌，聪明的他立刻意识到，他的血液里有什么了不得的东西。他有些兴奋，却没有把这件事告诉任何人。他知道一旦让其他人发现了端倪，必然会给他自己带来大麻烦。</p><p>　　苏景怕疼，自那以后也没有机会再动用他身体的能力。他小心翼翼地挤了挤自己的伤口，想让血流的更多更快些。他蹲下身子，将左臂悬在少年的额头上，让血滴落的位置正好在少年嘴唇的上方。他又把右手在自己身上干净的地方擦了擦，然后用食指试探性地想要撬开少年紧抿的唇瓣。</p><p>　　少年不知道是痛的牙关紧闭还是不喜欢嘴巴被人触碰，苏景试探了好几次依旧没能让他把嘴巴张开。他动脉处的血滴在少年的唇瓣上，像是红梅落入冬雪。</p><p>　　苏景灵光一闪，低头在少年的耳畔悄声说了句“对不住了。”然后右手不轻不重地给少年的腹部来了一拳。平日里这种力度打在少年身上就如同隔靴搔痒，但他伤的实在太重，苏景一拳下去，少年就痛的忍不住张嘴抽气。</p><p>　　苏景瞅准机会，下意识的用力掐了掐自己的伤口，鲜血像山间细流似的落进少年的唇缝。苏景目不转睛的看着他，心里也有些紧张。这是他第一次主动给别人喂血，效果如何他自己也不太清楚。</p><p>　　不多久，只见少年的狼尾动了动，十数息的功夫之后就消失在虚空中，唇瓣也悄悄泛起了些微血色。“有效果了！”苏景心中大喜，紧绷的弦稍微松了些。</p><p>　　只是…苏景用神识探查了他的身体，生命体征微弱的像是一颗随时会熄灭的火苗，更别说风吹雨淋了。苏景叹了口气，默默把自己的袖子拉的更高些，然后又划了两道口子，一股脑的全喂进少年的嘴里。</p><p>　　苏景像是一位不断给火苗添柴的人，期望着火苗能越烧越旺。他就这么直愣愣的举着胳膊，等到手臂酸的快要抬不起来的时候，才用手边的野草给自己的伤口随意的处理了一下。</p><p>　　苏景看着少年刀口周围的污泥和血垢，便想着背他去山脚边的溪流。正当他试图抬起少年的手臂时，却发现他右手的五个手指全都微蜷着插在泥土当中。</p><p>　　苏景把手覆在少年的手背上，掌心发力，一点点地将少年的手从泥土里分开。当他再次抬起少年的胳膊时，一枚暗红的狼牙戒指从少年的手掌心滑落。</p><p>　　苏景估摸着这是对他很重要的物品，便从身上扯下一块料子，将戒指小心翼翼的包好，然后带在身上。他背起少年的时候才发现，少年比他要高出半个额头，而且…苏景感受到自己的小腿在微微的颤抖，心里嘀咕道：“狼族都这么重的吗！”</p><p>　　到了溪边，苏景将少年安放在一棵青柏旁，将一直带在身上的野果子拿到溪边冲洗干净，又将包果子的布料来回洗了好几遍，方才回到少年身边，清理着他身上化脓的血口子。</p><p>　　清理的时候苏景才知道什么叫触目惊心。岂止是刀口子，他背上有五处被穿喉箭中伤的痕迹，箭矢上有防止伤口愈合的药，到现在还在血流不止。腰背上还有数道被刮骨鞭鞭笞的痕迹，血肉模糊，伤口之深可见白骨。尤其是心口处的那几道口子…苏景每清理一处心便俞沉一分。</p><p>　　等苏景将所有的伤口处理完毕时，天空已是墨色。他轻轻拭去少年面上的尘土，露出一张棱角分明的脸。少年还未清醒，双目紧闭，眉宇间却带着戾气。苏景本以为自己长的够俊了，却不得不承认眼前的少年比他要更多几分峻朗。</p><p>　　苏景坐在少年的身侧，又在自己右臂上划了几刀。他一边给少年喂血，一边阖上眼准备休息。但是手臂不时传来的疼痛让他毫无睡意，便强睁着大眼睛数天上的星星。数着数着，便模模糊糊的睡着了。</p><p>　　就这么过了一日，两日…苏景看着少年身上的伤口正在逐渐愈合，估摸着再有个十几日的功夫，他就可以宣布他从阎王爷手中把人给抢回来了。</p><p>　　等到第三日早晨，苏景在睡梦中被脖颈处的一阵酥麻弄醒。他迷迷糊糊睁开眼睛，看到了一颗玄青色的狼脑袋。小狼还没有醒，嘴巴似乎咬着…自己的脖子？！</p><p>　　苏景瞬间清醒，他慢慢的试图把自己的脖子从它嘴巴里面悄悄挪出来。正当苏景挪出来的一刹那，小狼猛地惊醒。“你你你别咬脖子，咬脖子我就会死掉，死掉的话我就不能救你了！”苏景没过脑子的冲小狼嚷嚷着。</p><p>　　小狼歪头看着苏景，眼睛里面似乎透露着一种…看傻子的神情。它有气无力的咬住苏景的胳膊，又昏昏沉沉的睡了过去。苏景回过神来，摸了摸自己的脖子，没有任何的伤口。他意识到小狼没想伤害他，就由着他咬着自己的胳膊。</p><p>　　第七日的晚上，苏景去林子里找吃的。前几日小狼化成狼形，应该是妖族的自我保护机制，毕竟维持人形要消耗更多的能量，而狼形可以更好的恢复。他又找了一些野果子，准备等小狼化成人形的时候果腹。</p><p>　　正当他往回走的时候，发现少年模样的小狼在满地寻找着什么。苏景心领神会，赶紧跑到他身边，把自己身上一直带着的那枚戒指递给了小狼。小狼先是恶狠狠的盯着苏景看，后来想到什么似的，收起了眉宇间的戾气，自顾自的将自己蜷成一团，又沉沉的睡过去了。</p><p>　　苏景有些好笑的看着他这副模样，浅浅地对他说了句：“小白眼狼。”然后又娴熟的在自己手腕上划破几道口子，喂进小狼嘴里。他靠着小狼躺下，手有一搭没一搭的轻轻拍在小狼背上，嘴里念叨着：“没事的，都过去了，都过去了…”</p><p>　　第九日，苏景不知为何一觉睡到了正午。这两日他总觉得身体有些疲软，可能是流了太多的血，又或者是天气炎热了几分。苏景在睡梦中不断的翻身，试图逃离阳光的照射。恍惚间，有一道阴影蒙上了他的眼睛，为他隔绝了晃眼的光。</p><p>　　等苏景醒来时，正好和一双深邃的眸子对视，黑曜石般的瞳孔里，仿佛燃烧着熊熊的烈火。苏景还没回过神，就看到眼前的人低身伏于自己的耳畔边，用清冷又炙热的声音对他说：“你是谁，为什么要救我。”</p><p>　　朱阳当空，烛火燎原。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 · 池鱼覆清泥💙</title>
    <link href="/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/11/15/%E5%86%99%E4%BD%9C/%E5%8D%97%E5%86%A0%E6%AC%B2%E7%83%82%E6%9F%AF/%E5%8D%97%E5%86%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="池鱼覆清泥"><a href="#池鱼覆清泥" class="headerlink" title="池鱼覆清泥"></a>池鱼覆清泥</h1><p> 崇宁十七年，夏。</p><p>　　大赢和大乾边境交界处，有一片绵延万里的峰群，高低起伏的碧山翠峦间，有一座不起眼的山头。山头上满是扎根了数千年的烟松，四季常绿，他们像是风霜饱经后的老者，仍怀揣着一颗稚子之心，年年常乐。</p><p>　　远处几只结伴的闲云鹤悠悠飞来，在这片松林旁驻足小憩。闲云鹤性怯，喜静，寻常人一生都看不到他们的踪影，今日这座山头却能引得它们落脚歇息，想来是发觉这片林子没有人迹。</p><p>　　山脚边有一条小溪深深浅浅的流淌着，溪水中生活着一种独特的鱼，在太阳照射下其鳞生霓色，故而称其“彩鳞鲭”。阳光在水面铺开时，会有彩色的流光自水里晕染开来，像是把整个大赢的胭脂都倒进了溪水当中，故而这条溪水又被称作“彩粼溪”。</p><p>　　那几只闲云鹤正立在烟松边上闲散地整理着羽翼，突然从彩粼溪的方向传来了“扑通”的落水声，紧跟着又传来一声“哎呦——”。声音不算太大，却也惊的闲云鹤们如临大敌似的振翅而逃，仓皇间还能腾出空朝彩粼溪那边探个脑袋，隐约能瞧着溪边有两道模糊的人影。</p><p>　　其中一名头戴蓑笠帽的少年低坐在溪旁，不急不徐的将裤脚卷到及膝的位置，又拢了拢袖子，从身侧拿出一个竹篓，熟练的将篓中的衣物放入溪水中，帽檐将少年的脸尽数没入阴影，可水里倒映出的那张脸，连隔壁家的小奶猫见了都要羞的转身就跑。</p><p>　　少年浣衣的同时，眼睛不时瞟向一旁，别家的小奶猫跑不跑不知道，但自家这位…刚刚那声“哎哟”便是自家这位“小奶猫”抓鱼不成，反将自己扑空在水里湿了个满身发出来的哀嚎。</p><p>　　这位“小奶猫”也没有气馁，重新调整了姿势，深吸了一口气，然后屏住呼吸，将大半个身子都没在水中，只露出一双亮闪闪的眼睛，眨也不眨地盯着几条浑不知情的游鱼在水里交尾欢腾，其间虹芒交相辉映。</p><p>　　片刻过后，他猫似的缓缓弓起背，嘴唇翕动，水面腾的升起一层薄雾和光晕，光晕缓缓向鱼群拢去，原本在水中撒欢的鱼儿突然安静下来，只有尾巴还在轻微的摆动着。就在鱼群失神的瞬间，这位少年忽地向鱼群扑去，溅起巨大的水花和池底的青泥。</p><p>　　浣衣的少年正在抖落一件刚洗净的素色长衫上的水珠，耳畔边便传来了水花溅落的声响，还没反应过来声响的缘由，便见到青泥将手中的长衫又沾了个满怀。</p><p>　　少年的手顿时僵住，额头青筋猛跳，他闭上眼，努力长吸了一口气，试图压抑自己的情绪，好一会儿后方才咬着牙，睁开眼睛，冲着抓鱼的少年从牙缝中生生挤出几个字：“苏景！你能不能——”</p><p>　　话还没说到一半，苏景就从水里起了身，手里抓着一条活蹦乱跳的彩鳞鲭。夏日的阳光在这片茂密的山林里也只能堪堪从树叶的缝隙里漏出几片金纱，金纱似的光芒笼在苏景脸上，让人移不开眼。</p><p>　　浣衣少年盯着他怔了片刻，刚刚还作势要吓唬苏景的气焰被眼前的场景一下子打消了，顷刻间化作笑意，望着苏景那张被泥星子遮得严严实实的脸，只剩两只扑闪闪的大眼睛露在外面。</p><p>　　“苏野你快看！这条彩鳞鲭的个头比以往抓的那些都要大！”苏景一手叉着腰，一手举起刚抓的家伙朝苏野那边使劲儿晃了晃，泥星子也遮不住脸上的兴奋劲儿。</p><p>　　苏野象征性的朝苏景比了个大拇指，又从自己衣服里面掏出一条干净的帕子递过去，然后伸手接过他手里抓着的那条彩鳞鲭，声音淡淡，目光中却含着不易察觉的笑意说道：“把脸擦擦。”</p><p>　　待苏景将帕子在脸上胡乱抹了几下之后，苏野用手舀了勺清水，一把薅过苏景的脖子，他看似大力实则不轻不重的将苏景脸上的泥点子抹了个干干净净，而后捏了捏苏景被抹地有些发红的脸蛋，这才满意的将人放了回去。</p><p>　　“这人怎么擦脸也这么用力。”苏景小声嘟囔着，苏野站在一旁，将苏景的嘀咕听了个清楚。他看着苏景的脸，不知为何突然想将梅花酒倒进牛乳里面试试，看看是不是也会像苏景的脸这般，白里泛着红。</p><p>　　苏景一边拧了拧自己湿透的衣服，一边对苏野说道：“奶奶今天的腰伤又发作了，眼睛也看不太清楚，咱们回去的时候去趟王爷爷那，请他老人家再给奶奶瞧瞧，顺便再去趟——”，苏景话没说完，突然想起什么似的闭上了嘴，拧衣服的手速加快，余光却看向了苏野，好像在打量苏野有没有听到他那后半句话。</p><p>　　苏野嗯了一声，状似没听见后半句话地整理着篓中的衣物，心里却明白苏景的小算盘。前段日子苏景迷上了沈姨家从镇上寻来的话本子，吃饭也看，睡觉也看，连同他讲话时也总是想着话本子里的故事。</p><p>　　苏野气闷，担心他因为太过入迷而荒废了修炼，便将话本子还给了沈姨。苏景知道后去找苏野理论，苏野只回了他四个字：“为了你好。”苏景自知打不过苏野，但是又心心念念着话本子的后续，便盘算着再偷偷去趟沈姨那把话本子拿回来。</p><p>　　正当苏野将脏了的手帕和长衫重新放入溪水冲洗时，余光瞥见了一道准备溜走的身影。只见苏景偷偷摸摸的翻转手掌结了一印，脚尖轻点地面，脚底生成一股难以察觉的暗风，恍惚间便向林子里急掠而去。</p><p>　　“凌风步修的不错。”苏野望向苏景离开的方向，心中想道。他不慌不忙地将手里的帕子拧干，装进竹篓。等一切收拾好了以后，心念微动，凝神催发着体内的血脉之力，霎时间背后幻化出一道巨大的黑色虚影，周身暗红色的光芒跃动，同时脚掌发力，裹挟着劲风朝苏景离开的方向赶去。</p><p>　　苏景前行的过程中，心神凝聚，眸色变幻，目光含鎏。他将神识朝后方扩散开，一圈圈鎏色的能量波动以苏景为中心，悄悄隐匿在空气中跃动的微尘内，时刻关注着后方苏野的动静。</p><p>　　十数息后，一道苏景极为熟稔的能量潮和苏景的神识碰撞在一起，像是暴雨骤袭潭水，暗红和鎏金色的能量溅玉喷珠般的向四周迸裂。苏景心中一惊，没想到苏野这么快就追上来了，正欲催动内力加快速度，不料后颈处袭来一阵潮湿灼热之感，紧接着便被脖子处的拉力拖着往下栽。</p><p>　　苏野头快要着地的瞬间，眼前突然出现了一团毛茸茸的玄青色尾巴，将苏景稳稳当当地接住。钳住苏景后颈的力量松开后，苏景正想揉揉被弄的有些发痒的脖子，却又被两个厚重有力的爪子翻了个身，一张黑色的狼脸就这么出现在苏景的眸子里。</p><p>　　“苏野你快变回去，重死我了。”苏景被小狼压的没办法移动，大声嚷嚷。小狼没有理睬，低下头，使劲儿蹭了蹭苏景的脸，然后轻轻地将苏景从后颈舐到耳垂。</p><p>　　有时候苏景会想，狼形和人形的苏野到底是不是共用同一个神识，人形的苏野看上去正正经经，怎么狼形的苏野这么…苏景不知道怎么形容，只能任由小狼把他压着。</p><p>　　小狼看他一副任凭处置的躺在那，不由有些好笑。他抬起头颅，心念微动，赤色的流光闪烁间，钳住苏景的爪子骤然变成了两条孔武有力的胳膊。</p><p>　　夏日的天气炎热，即使在林中，追逐过后苏景也有些微汗涔涔。苏野正准备收回自己压着苏景的手，突然看到了苏景额头和脸颊渗出的汗珠。</p><p>　　苏野晃了晃神，脑子里不受控制的想到了刚温好的牛乳，又想到了十五的月亮……苏野摇摇头，觉得这些都不及苏景白。苏野又低头看了看自己黑黢黢的胳膊，暗叹太阳有点过于关照他了些。</p><p>　　苏景挣脱开苏野，活动了一下有些发酸的胳膊，袖口滑到了手肘。苏野一眼就注意到了苏景手臂上深浅不一，密密麻麻的划口，不由眉头微皱，心里沉了沉。</p><p>　　苏野心情急转直下间，没有发现，一道隐匿在背后的神识顺着他的领口溜到了后背。坐在一旁的苏景神情微变，心中一怔，他神识见到的，是一道道扭曲骇人的疤痕。如同一条条狰狞的千足之虫附着在苏野的背上。</p><p>　　两个人就这么静静的看着彼此，谁都没有开口说话。过了好一会儿，苏景才笑着说道：“愣着做什么，拉我起来，我腿麻了。”苏野这才回过神，一把扶起苏景，拍了拍他后背上的灰尘，轻声对他说：“你先回去，我去趟竹林。”苏景也没过问他去干什么，只是冲苏野笑了笑，然后往回家的方向走去了。</p><p>　　苏野看着苏景的背影逐渐消失在他的眼底，又盯了片刻，方才回头往竹林的方向走去。暮色悄悄地将整片林子没入橘黄，也悄悄地聆听着少年们的心事。</p><p>　　彩粼溪中两条游鱼追逐打闹着，不小心将池底的青泥翻了个痛快。又或许很多不堪的前尘往事也随着这些泥泞一起，被侵覆出水面了。  </p>]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>南冠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AE变形动画！🫧</title>
    <link href="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="AE变形动画"><a href="#AE变形动画" class="headerlink" title="AE变形动画"></a>AE变形动画</h1><h2 id="1-人偶位置控点工具"><a href="#1-人偶位置控点工具" class="headerlink" title="1.人偶位置控点工具"></a>1.人偶位置控点工具</h2><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/1.png"></p><p><strong>效果：</strong></p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/2.png"></p><p>操纵黄色的点可对其进行变形。</p><h2 id="2-贝塞尔曲线"><a href="#2-贝塞尔曲线" class="headerlink" title="2.贝塞尔曲线"></a>2.贝塞尔曲线</h2><p>在创建形状图层时勾选贝塞尔曲线路径</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/3.png"></p><p>创建两个不同的贝塞尔曲线路径，路径之间可以相互复制粘贴</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/4.png"></p><p>创建两个关键帧，实现图形的变换</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/5.png"></p><h2 id="3-合并路径"><a href="#3-合并路径" class="headerlink" title="3.合并路径"></a>3.合并路径</h2><p>创建两条或多条路径，在添加处点击合并路径选项</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/6.png"></p><p>产生新的内容——<strong>合并路径</strong>，选择模式</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/7.png"></p><p>不同的模式会产生不同的效果，下图为相减时产生的效果</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/8.png"></p><p><strong>注意：</strong>路径的上下顺序会改变合并路径的效果</p><p><strong>❗️Tips：</strong>Ctrl+G可以对内容进行打组，如下图所示：</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/9.png"></p><h2 id="4-中继器"><a href="#4-中继器" class="headerlink" title="4.中继器"></a>4.中继器</h2><p>可将多个图形按照一定规则进行复制</p><p>同样在<strong>添加</strong>中找到中继器</p><p><strong>注意：</strong>中继器会对其位置上方的内容进行复制</p><p>若希望进行对称变换，可以调整中继器变换的比例属性</p><p><img src="/2023/11/14/Adobe/AE/%E6%8A%80%E5%B7%A7/AE%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB/10.png"></p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>AE</category>
      
      <category>AE动画设计技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>AE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毛茸茸字体！🌞</title>
    <link href="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/"/>
    <url>/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/</url>
    
    <content type="html"><![CDATA[<h1 id="毛茸茸字体"><a href="#毛茸茸字体" class="headerlink" title="毛茸茸字体"></a>毛茸茸字体</h1><p>效果如下图所示：</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/1.png"></p><p>实现该效果需要用到三个步骤：</p><p>1.混合工具</p><p>2.钢笔工具</p><p>3.效果</p><h2 id="1-混合工具构建基本样式"><a href="#1-混合工具构建基本样式" class="headerlink" title="1.混合工具构建基本样式"></a>1.混合工具构建基本样式</h2><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/2.png"></p><p>设定混合选项</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/3.png"></p><p>选择混合距离1.5px</p><p>再进行对象—-&gt;混合——&gt;建立</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/4.png"></p><p>效果如上所示</p><h2 id="2-钢笔工具画出想要的字体"><a href="#2-钢笔工具画出想要的字体" class="headerlink" title="2.钢笔工具画出想要的字体"></a>2.钢笔工具画出想要的字体</h2><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/5.png"></p><p><strong>注意：</strong>画好的字体必须是连接起来的字体</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/6.png"></p><p>替换混合轴后效果如下图所示</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/7.png"></p><h2 id="3-效果"><a href="#3-效果" class="headerlink" title="3.效果"></a>3.效果</h2><p>在粗糙化选项中进行属性编辑</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/8.png"></p><p>编辑属性如下</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/9.png"></p><p>最终效果如下所示：</p><p><img src="/2023/11/14/Adobe/Ai/%E8%AE%BE%E8%AE%A1/Ai%E8%AE%BE%E8%AE%A11/10.png"></p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>Ai</category>
      
      <category>Ai设计案例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai钢笔工具的使用！🌸</title>
    <link href="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ai钢笔工具的使用"><a href="#Ai钢笔工具的使用" class="headerlink" title="Ai钢笔工具的使用"></a>Ai钢笔工具的使用</h1><h2 id="1-找到凹凸曲线的交界点"><a href="#1-找到凹凸曲线的交界点" class="headerlink" title="1.找到凹凸曲线的交界点"></a>1.找到凹凸曲线的交界点</h2><p><img src="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/1.png"></p><p>如上图所示即是凹凸曲线的交界点</p><p>该临界点是钢笔落点的基本位置</p><h2 id="2-每条凹凸曲线的范围不超过180度"><a href="#2-每条凹凸曲线的范围不超过180度" class="headerlink" title="2.每条凹凸曲线的范围不超过180度"></a>2.每条凹凸曲线的范围不超过180度</h2><p><img src="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/2.png"></p><p>如图所示，曲线由两个端点所控制，而端点之间连城一条直线</p><p>直线是180度角</p><p>所以在选择两个钢笔的端点时，曲线角度不能超过180度</p><h2 id="3-控制凹凸曲线端点的手柄为切线"><a href="#3-控制凹凸曲线端点的手柄为切线" class="headerlink" title="3.控制凹凸曲线端点的手柄为切线"></a>3.控制凹凸曲线端点的手柄为切线</h2><p><img src="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/3.png"></p><p>如上图所示，在初始点的位置，控制左边手柄为左半边曲线的切线</p><p>然后按住<strong>Alt键</strong>改变右边手柄的方向和长度</p><p>使右边手柄为右半边曲线的切线</p><h2 id="4-端点手柄的长度决定曲线的倾斜程度"><a href="#4-端点手柄的长度决定曲线的倾斜程度" class="headerlink" title="4.端点手柄的长度决定曲线的倾斜程度"></a>4.端点手柄的长度决定曲线的倾斜程度</h2><p><img src="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/4.png"></p><p><img src="/2023/11/14/Adobe/Ai/%E6%8A%80%E5%B7%A7/Ai%E9%92%A2%E7%AC%94%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/5.png"></p><p>如上图所示，控制右边手柄的长度，可以看到曲线的倾斜角度发生了改变</p><p>长度越长，倾斜角度越大</p>]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
      <category>Ai</category>
      
      <category>Ai矢量图设计技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法整体认知思路！💁</title>
    <link href="/2023/11/01/%E7%AE%97%E6%B3%95/Algorithm-begin/"/>
    <url>/2023/11/01/%E7%AE%97%E6%B3%95/Algorithm-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法 ʕ≧ᴥ≦ʔ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《南冠欲烂柯》简介！👀</title>
    <link href="/2023/11/01/%E5%86%99%E4%BD%9C/Writing-begin/"/>
    <url>/2023/11/01/%E5%86%99%E4%BD%9C/Writing-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>写作 ʕ◉ᴥ◉ʔ</category>
      
      <category>《南冠欲烂柯》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>大纲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adobe全家桶流程概览！🧟‍♀️</title>
    <link href="/2023/11/01/Adobe/Adobe-begin/"/>
    <url>/2023/11/01/Adobe/Adobe-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Adobe ʕ￫ᴥ￩ʔ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路</tag>
      
      <tag>Adobe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能的应用场景！🤹🏼‍♀️</title>
    <link href="/2023/11/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI-begin/"/>
    <url>/2023/11/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>AI ʢᵕᴗᵕʡ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整体建模思路！🧝🏼‍♀️</title>
    <link href="/2023/11/01/%E5%BB%BA%E6%A8%A1/Maya-begin/"/>
    <url>/2023/11/01/%E5%BB%BA%E6%A8%A1/Maya-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>建模 ʕథ౪థʔ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路</tag>
      
      <tag>建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity整体架构思路！🙇🏻‍♂️</title>
    <link href="/2023/11/01/%E6%B8%B8%E6%88%8F/Unity-begin/"/>
    <url>/2023/11/01/%E6%B8%B8%E6%88%8F/Unity-begin/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Unity ᶘ ᵒᴥᵒᶅ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小杨来啦！🦸🏻‍♂️🦸🏻‍♂️🦸🏻‍♂️</title>
    <link href="/2023/10/31/%E6%97%A5%E8%AE%B0/kaixin/"/>
    <url>/2023/10/31/%E6%97%A5%E8%AE%B0/kaixin/</url>
    
    <content type="html"><![CDATA[<p>开心就好</p>]]></content>
    
    
    <categories>
      
      <category>思考 ʕ•ᴥ•ʔ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>情绪</tag>
      
      <tag>发疯</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
